<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ilang: ilang::InterIlaUnroller Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ilang
   &#160;<span id="projectnumber">1.0.5</span>
   </div>
   <div id="projectbrief">ILAng: A Modeling and Verification Platform for SoCs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceilang.html">ilang</a></li><li class="navelem"><a class="el" href="classilang_1_1_inter_ila_unroller.html">InterIlaUnroller</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classilang_1_1_inter_ila_unroller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ilang::InterIlaUnroller Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for unrolling multiple ILAs. There are two ways of unrolling: ordered and unordered. Ordered unrolling assumes an ordered program template, despite that some may not exist in the final outcome. By default the state with the same name among ILAs is considered as the same shared state.  
 <a href="classilang_1_1_inter_ila_unroller.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="inter__ila__unroller_8h_source.html">inter_ila_unroller.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a35e84754b0b5b10deee54b2ef7421ab1"><td class="memItemLeft" align="right" valign="top"><a id="a35e84754b0b5b10deee54b2ef7421ab1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a35e84754b0b5b10deee54b2ef7421ab1">ZExpr</a> = <a class="el" href="classilang_1_1_memory_model.html#a9c7a763da08245af4a9465d261ed483a">MemoryModel::ZExpr</a></td></tr>
<tr class="memdesc:a35e84754b0b5b10deee54b2ef7421ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for z3::expr. <br /></td></tr>
<tr class="separator:a35e84754b0b5b10deee54b2ef7421ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83ebf1fea382fb26be5c53052e86ae4"><td class="memItemLeft" align="right" valign="top"><a id="ae83ebf1fea382fb26be5c53052e86ae4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#ae83ebf1fea382fb26be5c53052e86ae4">ZExprVec</a> = <a class="el" href="classilang_1_1_memory_model.html#ab0d3de967acef0330edf4d65d5782ce5">MemoryModel::ZExprVec</a></td></tr>
<tr class="memdesc:ae83ebf1fea382fb26be5c53052e86ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for containing a vector of z3::expr. <br /></td></tr>
<tr class="separator:ae83ebf1fea382fb26be5c53052e86ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be4afc388acb3f408871255fedb96cf"><td class="memItemLeft" align="right" valign="top"><a id="a6be4afc388acb3f408871255fedb96cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a6be4afc388acb3f408871255fedb96cf">StateNameSet</a> = <a class="el" href="classilang_1_1_memory_model.html#a0950692c6a72496a2dda46aa985cb337">MemoryModel::StateNameSet</a></td></tr>
<tr class="memdesc:a6be4afc388acb3f408871255fedb96cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of state name set. <br /></td></tr>
<tr class="separator:a6be4afc388acb3f408871255fedb96cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0a224bb1edf4eef8a8b377dfe05e8a"><td class="memItemLeft" align="right" valign="top"><a id="a3a0a224bb1edf4eef8a8b377dfe05e8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a3a0a224bb1edf4eef8a8b377dfe05e8a">InstrVec</a> = <a class="el" href="classilang_1_1_memory_model.html#ac6cb2d9253fb53a10ea66fd1e71267bc">MemoryModel::InstrVec</a></td></tr>
<tr class="memdesc:a3a0a224bb1edf4eef8a8b377dfe05e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an instruction vector to represent a sequence. <br /></td></tr>
<tr class="separator:a3a0a224bb1edf4eef8a8b377dfe05e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc24c6ee17b58b05e18882d73c5affde"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#acc24c6ee17b58b05e18882d73c5affde">ProgramTemplate</a> = <a class="el" href="classilang_1_1_memory_model.html#a72bd17543b5e5cbaefeb994c933622f5">MemoryModel::ProgramTemplate</a></td></tr>
<tr class="separator:acc24c6ee17b58b05e18882d73c5affde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d4e092989c943ae2978dd9e01e016a"><td class="memItemLeft" align="right" valign="top"><a id="ab5d4e092989c943ae2978dd9e01e016a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#ab5d4e092989c943ae2978dd9e01e016a">ILANameStateNameSetMap</a> = <a class="el" href="classilang_1_1_memory_model.html#a9e23cd7d325902a4ab1a4f5d8acea67b">MemoryModel::ILANameStateNameSetMap</a></td></tr>
<tr class="memdesc:ab5d4e092989c943ae2978dd9e01e016a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of map ila-name to state-set. <br /></td></tr>
<tr class="separator:ab5d4e092989c943ae2978dd9e01e016a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cea73f936eeb438cdf33a8e9ccd9f6"><td class="memItemLeft" align="right" valign="top"><a id="a78cea73f936eeb438cdf33a8e9ccd9f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a78cea73f936eeb438cdf33a8e9ccd9f6">TraceStepPtrSet</a> = <a class="el" href="classilang_1_1_memory_model.html#adf275c2b36d17acd5b6e782c1eca7f92">MemoryModel::TraceStepPtrSet</a></td></tr>
<tr class="memdesc:a78cea73f936eeb438cdf33a8e9ccd9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of set of trace step pointers (DEBUG use) <br /></td></tr>
<tr class="separator:a78cea73f936eeb438cdf33a8e9ccd9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa955b80ccc2435d5c81bb8c3ea3659b2"><td class="memItemLeft" align="right" valign="top"><a id="aa955b80ccc2435d5c81bb8c3ea3659b2"></a>
typedef std::vector&lt; <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#aa955b80ccc2435d5c81bb8c3ea3659b2">IlaPtrVec</a></td></tr>
<tr class="memdesc:aa955b80ccc2435d5c81bb8c3ea3659b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of vector of pointers to the ILAs involved. <br /></td></tr>
<tr class="separator:aa955b80ccc2435d5c81bb8c3ea3659b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf26c108a1a2954c735c21e16373e81d"><td class="memItemLeft" align="right" valign="top"><a id="adf26c108a1a2954c735c21e16373e81d"></a>
typedef std::list&lt; <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#adf26c108a1a2954c735c21e16373e81d">StateVarList</a></td></tr>
<tr class="memdesc:adf26c108a1a2954c735c21e16373e81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of list of state variables. <br /></td></tr>
<tr class="separator:adf26c108a1a2954c735c21e16373e81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c14fdd9ecdb3c194c5620097aaf01e"><td class="memItemLeft" align="right" valign="top"><a id="a86c14fdd9ecdb3c194c5620097aaf01e"></a>
typedef std::map&lt; std::string, <a class="el" href="classilang_1_1_inter_ila_unroller.html#adf26c108a1a2954c735c21e16373e81d">StateVarList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a86c14fdd9ecdb3c194c5620097aaf01e">SharedStatesSet</a></td></tr>
<tr class="memdesc:a86c14fdd9ecdb3c194c5620097aaf01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of map of shared states (set of names -&gt; list of exprs) <br /></td></tr>
<tr class="separator:a86c14fdd9ecdb3c194c5620097aaf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4209693907f472d4bf20f4b1752232"><td class="memItemLeft" align="right" valign="top">typedef std::unique_ptr&lt; <a class="el" href="classilang_1_1_memory_model.html">MemoryModel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#aed4209693907f472d4bf20f4b1752232">MemoryModelPtr</a></td></tr>
<tr class="separator:aed4209693907f472d4bf20f4b1752232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7874a4d744387600038a4551080362"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; <a class="el" href="classilang_1_1_inter_ila_unroller.html#aed4209693907f472d4bf20f4b1752232">MemoryModelPtr</a>(z3::context &amp;, <a class="el" href="classilang_1_1_inter_ila_unroller.html#ae83ebf1fea382fb26be5c53052e86ae4">ZExprVec</a> &amp;, const <a class="el" href="classilang_1_1_inter_ila_unroller.html#a6be4afc388acb3f408871255fedb96cf">StateNameSet</a> &amp;, const <a class="el" href="classilang_1_1_inter_ila_unroller.html#ab5d4e092989c943ae2978dd9e01e016a">ILANameStateNameSetMap</a> &amp;, const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a8d7874a4d744387600038a4551080362">MemoryModelCreator</a></td></tr>
<tr class="separator:a8d7874a4d744387600038a4551080362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f08db6db6aac58581bad67ca778073e"><td class="memItemLeft" align="right" valign="top"><a id="a3f08db6db6aac58581bad67ca778073e"></a>
typedef std::shared_ptr&lt; <a class="el" href="classilang_1_1_trace_step.html">TraceStep</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a3f08db6db6aac58581bad67ca778073e">TraceStepPtr</a></td></tr>
<tr class="memdesc:a3f08db6db6aac58581bad67ca778073e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of trace step pointer. <br /></td></tr>
<tr class="separator:a3f08db6db6aac58581bad67ca778073e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5031e957f9a2b539bbfe3a21af489729"><td class="memItemLeft" align="right" valign="top"><a id="a5031e957f9a2b539bbfe3a21af489729"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a5031e957f9a2b539bbfe3a21af489729">InterIlaUnroller</a> (z3::context &amp;ctx, const <a class="el" href="classilang_1_1_inter_ila_unroller.html#aa955b80ccc2435d5c81bb8c3ea3659b2">IlaPtrVec</a> &amp;iv, <a class="el" href="classilang_1_1_inter_ila_unroller.html#a8d7874a4d744387600038a4551080362">MemoryModelCreator</a> mm_selector)</td></tr>
<tr class="memdesc:a5031e957f9a2b539bbfe3a21af489729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. mm_selector is used to create mm internally. <br /></td></tr>
<tr class="separator:a5031e957f9a2b539bbfe3a21af489729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f100076083324362da6147968c2fc2"><td class="memItemLeft" align="right" valign="top"><a id="ad3f100076083324362da6147968c2fc2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#ad3f100076083324362da6147968c2fc2">~InterIlaUnroller</a> ()</td></tr>
<tr class="memdesc:ad3f100076083324362da6147968c2fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:ad3f100076083324362da6147968c2fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dcb99558799f90604282e805f58ec1"><td class="memItemLeft" align="right" valign="top"><a id="a13dcb99558799f90604282e805f58ec1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a13dcb99558799f90604282e805f58ec1">GenSysInitConstraints</a> ()</td></tr>
<tr class="memdesc:a13dcb99558799f90604282e805f58ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">it generates the initial constraints and put them on to the constraint list and check should be called before unroll <br /></td></tr>
<tr class="separator:a13dcb99558799f90604282e805f58ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56ad07cf9d03caa3f1fb10091779dc0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#ac56ad07cf9d03caa3f1fb10091779dc0">Unroll</a> (const <a class="el" href="classilang_1_1_inter_ila_unroller.html#acc24c6ee17b58b05e18882d73c5affde">ProgramTemplate</a> &amp;tmpl)</td></tr>
<tr class="memdesc:ac56ad07cf9d03caa3f1fb10091779dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Application-specific] Unroll, currently just use PathUnroller  <a href="#ac56ad07cf9d03caa3f1fb10091779dc0">More...</a><br /></td></tr>
<tr class="separator:ac56ad07cf9d03caa3f1fb10091779dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3dc348887464db257ac8bd84c36324"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a7a3dc348887464db257ac8bd84c36324">LinkStates</a> (const std::vector&lt; bool &gt; &amp;ordered)</td></tr>
<tr class="memdesc:a7a3dc348887464db257ac8bd84c36324"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Application-specific] Link states, where each trace step read from  <a href="#a7a3dc348887464db257ac8bd84c36324">More...</a><br /></td></tr>
<tr class="separator:a7a3dc348887464db257ac8bd84c36324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4a41a5a7bcd6ec89e757bc12823da7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a2c4a41a5a7bcd6ec89e757bc12823da7">AddSingleTraceStepProperty</a> (const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;property, std::function&lt; bool(const <a class="el" href="classilang_1_1_trace_step.html">TraceStep</a> &amp;)&gt; filter)</td></tr>
<tr class="memdesc:a2c4a41a5a7bcd6ec89e757bc12823da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a property.  <a href="#a2c4a41a5a7bcd6ec89e757bc12823da7">More...</a><br /></td></tr>
<tr class="separator:a2c4a41a5a7bcd6ec89e757bc12823da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae341d1d6ee4ce09419821a970cc79c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#ae341d1d6ee4ce09419821a970cc79c39">GetSingleTraceStepProperty</a> (const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;property, std::function&lt; bool(const <a class="el" href="classilang_1_1_trace_step.html">TraceStep</a> &amp;)&gt; filter, std::function&lt; void(const z3::expr &amp;)&gt; collector)</td></tr>
<tr class="memdesc:ae341d1d6ee4ce09419821a970cc79c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the z3 expression of a property on a trace step, so you can play with it.  <a href="#ae341d1d6ee4ce09419821a970cc79c39">More...</a><br /></td></tr>
<tr class="separator:ae341d1d6ee4ce09419821a970cc79c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d187936775e69e41c24fbef3aa5ca22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a7d187936775e69e41c24fbef3aa5ca22">SetFinalProperty</a> (const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;property)</td></tr>
<tr class="memdesc:a7d187936775e69e41c24fbef3aa5ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set final property (you should only call this function only ONCE)  <a href="#a7d187936775e69e41c24fbef3aa5ca22">More...</a><br /></td></tr>
<tr class="separator:a7d187936775e69e41c24fbef3aa5ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4916b8b8859c4c9d7f8880c59520ea5b"><td class="memItemLeft" align="right" valign="top"><a id="a4916b8b8859c4c9d7f8880c59520ea5b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a4916b8b8859c4c9d7f8880c59520ea5b">CheckSat</a> ()</td></tr>
<tr class="memdesc:a4916b8b8859c4c9d7f8880c59520ea5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and potentially set the model: return true if sat , false o.w. <br /></td></tr>
<tr class="separator:a4916b8b8859c4c9d7f8880c59520ea5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393cee916d7f0227348e7d155c0fd8e"><td class="memItemLeft" align="right" valign="top"><a id="a7393cee916d7f0227348e7d155c0fd8e"></a>
z3::model &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a7393cee916d7f0227348e7d155c0fd8e">GetModel</a> ()</td></tr>
<tr class="memdesc:a7393cee916d7f0227348e7d155c0fd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the model: the reference will only be usable if unroller is not destroyed. <br /></td></tr>
<tr class="separator:a7393cee916d7f0227348e7d155c0fd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904c8501311d1f0ab7c8a57002797dc9"><td class="memItemLeft" align="right" valign="top"><a id="a904c8501311d1f0ab7c8a57002797dc9"></a>
const <a class="el" href="classilang_1_1_inter_ila_unroller.html#ae83ebf1fea382fb26be5c53052e86ae4">ZExprVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a904c8501311d1f0ab7c8a57002797dc9">DebugAccessConstrList</a> () const</td></tr>
<tr class="memdesc:a904c8501311d1f0ab7c8a57002797dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to expr vector, will only be usable if unroller is not destroyed, only for DEBUG use. <br /></td></tr>
<tr class="separator:a904c8501311d1f0ab7c8a57002797dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156f2962b14bfa373df3c8aaa7957aea"><td class="memItemLeft" align="right" valign="top"><a id="a156f2962b14bfa373df3c8aaa7957aea"></a>
const <a class="el" href="classilang_1_1_inter_ila_unroller.html#a78cea73f936eeb438cdf33a8e9ccd9f6">TraceStepPtrSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a156f2962b14bfa373df3c8aaa7957aea">DebugAccessAllTraceStepPtrSet</a> () const</td></tr>
<tr class="memdesc:a156f2962b14bfa373df3c8aaa7957aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to expr vector, will only be usable if unroller is not destroyed, only for DEBUG use. <br /></td></tr>
<tr class="separator:a156f2962b14bfa373df3c8aaa7957aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29b2b4958a7fc8ab39dc48913435add"><td class="memItemLeft" align="right" valign="top"><a id="aa29b2b4958a7fc8ab39dc48913435add"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#aa29b2b4958a7fc8ab39dc48913435add">Push</a> ()</td></tr>
<tr class="memdesc:aa29b2b4958a7fc8ab39dc48913435add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the size of current set of constraints. <br /></td></tr>
<tr class="separator:aa29b2b4958a7fc8ab39dc48913435add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922a75c80f16820692b720e6151885eb"><td class="memItemLeft" align="right" valign="top"><a id="a922a75c80f16820692b720e6151885eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a922a75c80f16820692b720e6151885eb">Pop</a> ()</td></tr>
<tr class="memdesc:a922a75c80f16820692b720e6151885eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previous set of constraints. <br /></td></tr>
<tr class="separator:a922a75c80f16820692b720e6151885eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aea10fd80ffa6f186591735812473d54c"><td class="memItemLeft" align="right" valign="top"><a id="aea10fd80ffa6f186591735812473d54c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#aea10fd80ffa6f186591735812473d54c">FindSharedStates</a> ()</td></tr>
<tr class="memdesc:aea10fd80ffa6f186591735812473d54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It create a name list. There is no need to create an ExprPtr list because their hosts are different and will generate different z3exprs. <br /></td></tr>
<tr class="separator:aea10fd80ffa6f186591735812473d54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed907c324b08115a75807052e25b3bb9"><td class="memItemLeft" align="right" valign="top"><a id="aed907c324b08115a75807052e25b3bb9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#aed907c324b08115a75807052e25b3bb9">CurrConstrSat</a> ()</td></tr>
<tr class="memdesc:aed907c324b08115a75807052e25b3bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanity check if the current constraints are satisfiable. <br /></td></tr>
<tr class="separator:aed907c324b08115a75807052e25b3bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6ea3c5d710936ec0d869d584cc96fd"><td class="memItemLeft" align="right" valign="top"><a id="aba6ea3c5d710936ec0d869d584cc96fd"></a>
<a class="el" href="classilang_1_1_inter_ila_unroller.html#a35e84754b0b5b10deee54b2ef7421ab1">ZExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#aba6ea3c5d710936ec0d869d584cc96fd">ConjPred</a> (const <a class="el" href="classilang_1_1_inter_ila_unroller.html#ae83ebf1fea382fb26be5c53052e86ae4">ZExprVec</a> &amp;vec) const</td></tr>
<tr class="memdesc:aba6ea3c5d710936ec0d869d584cc96fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjunct (AND) all the predicates in the set. <br /></td></tr>
<tr class="separator:aba6ea3c5d710936ec0d869d584cc96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3e35f38a342c994afe43edc13ed77bd5"><td class="memItemLeft" align="right" valign="top"><a id="a3e35f38a342c994afe43edc13ed77bd5"></a>
<a class="el" href="classilang_1_1_inter_ila_unroller.html#aa955b80ccc2435d5c81bb8c3ea3659b2">IlaPtrVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a3e35f38a342c994afe43edc13ed77bd5">sys_ila_</a></td></tr>
<tr class="memdesc:a3e35f38a342c994afe43edc13ed77bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ILAs of an SoC. <br /></td></tr>
<tr class="separator:a3e35f38a342c994afe43edc13ed77bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece8433c151904e49a68611f53b45f0f"><td class="memItemLeft" align="right" valign="top"><a id="aece8433c151904e49a68611f53b45f0f"></a>
<a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#aece8433c151904e49a68611f53b45f0f">global_ila_</a></td></tr>
<tr class="memdesc:aece8433c151904e49a68611f53b45f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ILA of the system. <br /></td></tr>
<tr class="separator:aece8433c151904e49a68611f53b45f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d8777fb33aa08f416f1681cca8188c"><td class="memItemLeft" align="right" valign="top"><a id="a91d8777fb33aa08f416f1681cca8188c"></a>
<a class="el" href="classilang_1_1_inter_ila_unroller.html#a6be4afc388acb3f408871255fedb96cf">StateNameSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a91d8777fb33aa08f416f1681cca8188c">shared_states_</a></td></tr>
<tr class="memdesc:a91d8777fb33aa08f416f1681cca8188c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of names of shared states. <br /></td></tr>
<tr class="separator:a91d8777fb33aa08f416f1681cca8188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7aeda8ba6169eda6fbc57c0481386de"><td class="memItemLeft" align="right" valign="top"><a id="ac7aeda8ba6169eda6fbc57c0481386de"></a>
<a class="el" href="classilang_1_1_inter_ila_unroller.html#ab5d4e092989c943ae2978dd9e01e016a">ILANameStateNameSetMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#ac7aeda8ba6169eda6fbc57c0481386de">private_states_</a></td></tr>
<tr class="memdesc:ac7aeda8ba6169eda6fbc57c0481386de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from ila-name to set-of-state-names. <br /></td></tr>
<tr class="separator:ac7aeda8ba6169eda6fbc57c0481386de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19040211712fa2f0584ce55f950aed29"><td class="memItemLeft" align="right" valign="top"><a id="a19040211712fa2f0584ce55f950aed29"></a>
<a class="el" href="classilang_1_1_inter_ila_unroller.html#ae83ebf1fea382fb26be5c53052e86ae4">ZExprVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a19040211712fa2f0584ce55f950aed29">cstr_</a></td></tr>
<tr class="memdesc:a19040211712fa2f0584ce55f950aed29"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of constraints that should be asserted. <br /></td></tr>
<tr class="separator:a19040211712fa2f0584ce55f950aed29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386d5901334665f7318e404944b2965b"><td class="memItemLeft" align="right" valign="top"><a id="a386d5901334665f7318e404944b2965b"></a>
<a class="el" href="classilang_1_1_inter_ila_unroller.html#ae83ebf1fea382fb26be5c53052e86ae4">ZExprVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html#a386d5901334665f7318e404944b2965b">init_shared_vars_z3_</a></td></tr>
<tr class="memdesc:a386d5901334665f7318e404944b2965b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of constraints that should be asserted. <br /></td></tr>
<tr class="separator:a386d5901334665f7318e404944b2965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2a502ee5bc6cd8e1f708dc4b77d85385"><td class="memItemLeft" align="right" valign="top"><a id="a2a502ee5bc6cd8e1f708dc4b77d85385"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryModel</b></td></tr>
<tr class="separator:a2a502ee5bc6cd8e1f708dc4b77d85385"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for unrolling multiple ILAs. There are two ways of unrolling: ordered and unordered. Ordered unrolling assumes an ordered program template, despite that some may not exist in the final outcome. By default the state with the same name among ILAs is considered as the same shared state. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8d7874a4d744387600038a4551080362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7874a4d744387600038a4551080362">&#9670;&nbsp;</a></span>MemoryModelCreator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;<a class="el" href="classilang_1_1_inter_ila_unroller.html#aed4209693907f472d4bf20f4b1752232">MemoryModelPtr</a>( z3::context&amp;, <a class="el" href="classilang_1_1_inter_ila_unroller.html#ae83ebf1fea382fb26be5c53052e86ae4">ZExprVec</a>&amp;, const <a class="el" href="classilang_1_1_inter_ila_unroller.html#a6be4afc388acb3f408871255fedb96cf">StateNameSet</a>&amp;, const <a class="el" href="classilang_1_1_inter_ila_unroller.html#ab5d4e092989c943ae2978dd9e01e016a">ILANameStateNameSetMap</a>&amp;, const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&amp; )&gt; <a class="el" href="classilang_1_1_inter_ila_unroller.html#a8d7874a4d744387600038a4551080362">ilang::InterIlaUnroller::MemoryModelCreator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of memory model creator, nees to be the same as the ctor of MemoryModelClass </p>

</div>
</div>
<a id="aed4209693907f472d4bf20f4b1752232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4209693907f472d4bf20f4b1752232">&#9670;&nbsp;</a></span>MemoryModelPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unique_ptr&lt;<a class="el" href="classilang_1_1_memory_model.html">MemoryModel</a>&gt; <a class="el" href="classilang_1_1_inter_ila_unroller.html#aed4209693907f472d4bf20f4b1752232">ilang::InterIlaUnroller::MemoryModelPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of memory model pointer, we enforce ownership strictly, so it cannot be used else where </p>

</div>
</div>
<a id="acc24c6ee17b58b05e18882d73c5affde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc24c6ee17b58b05e18882d73c5affde">&#9670;&nbsp;</a></span>ProgramTemplate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classilang_1_1_inter_ila_unroller.html#acc24c6ee17b58b05e18882d73c5affde">ilang::InterIlaUnroller::ProgramTemplate</a> =  <a class="el" href="classilang_1_1_memory_model.html#a72bd17543b5e5cbaefeb994c933622f5">MemoryModel::ProgramTemplate</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a vector of instruction sequences (currently please represent holes via 0-ary functions) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2c4a41a5a7bcd6ec89e757bc12823da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4a41a5a7bcd6ec89e757bc12823da7">&#9670;&nbsp;</a></span>AddSingleTraceStepProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::InterIlaUnroller::AddSingleTraceStepProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classilang_1_1_trace_step.html">TraceStep</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>property that is going to translated to Z3, note: the state are treated as prestate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>filter to choose which trace step to enforce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae341d1d6ee4ce09419821a970cc79c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae341d1d6ee4ce09419821a970cc79c39">&#9670;&nbsp;</a></span>GetSingleTraceStepProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::InterIlaUnroller::GetSingleTraceStepProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classilang_1_1_trace_step.html">TraceStep</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const z3::expr &amp;)&gt;&#160;</td>
          <td class="paramname"><em>collector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the z3 expression of a property on a trace step, so you can play with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>property that is going to translated to Z3, note: the state are treated as prestate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>filter to choose which trace step to enforce </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>collector (callback function) to do something as each time a property is created on a step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a3dc348887464db257ac8bd84c36324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3dc348887464db257ac8bd84c36324">&#9670;&nbsp;</a></span>LinkStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ilang::InterIlaUnroller::LinkStates </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>ordered</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[Application-specific] Link states, where each trace step read from </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">whether</td><td>each template should be treated as ordered or unordered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d187936775e69e41c24fbef3aa5ca22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d187936775e69e41c24fbef3aa5ca22">&#9670;&nbsp;</a></span>SetFinalProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::InterIlaUnroller::SetFinalProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set final property (you should only call this function only ONCE) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac56ad07cf9d03caa3f1fb10091779dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56ad07cf9d03caa3f1fb10091779dc0">&#9670;&nbsp;</a></span>Unroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ilang::InterIlaUnroller::Unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_inter_ila_unroller.html#acc24c6ee17b58b05e18882d73c5affde">ProgramTemplate</a> &amp;&#160;</td>
          <td class="paramname"><em>tmpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[Application-specific] Unroll, currently just use PathUnroller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>program template. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="inter__ila__unroller_8h_source.html">inter_ila_unroller.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
