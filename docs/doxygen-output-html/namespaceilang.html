<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ilang: ilang Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ilang
   &#160;<span id="projectnumber">1.0.2</span>
   </div>
   <div id="projectbrief">ILAng: A Modeling and Verification Platform for SoCs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ilang Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_abs_knob.html">AbsKnob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ast.html">Ast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for the Abstract Syntax Tree. An <a class="el" href="classilang_1_1_ast.html" title="The class for the Abstract Syntax Tree. An Ast object can be an expression or function definition (in...">Ast</a> object can be an expression or function definition (interpreted or uninterpreted).  <a href="classilang_1_1_ast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_bool_val.html">BoolVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing Boolean values.  <a href="classilang_1_1_bool_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_bv_val.html">BvVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing Bitvector values.  <a href="classilang_1_1_bv_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_cex_extractor.html">CexExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the class to extract counterexample from a vcd file  <a href="classilang_1_1_cex_extractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_comm_diag.html">CommDiag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator for commutating diagram-based equivalence checking.  <a href="classilang_1_1_comm_diag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_comp_ref_rel.html">CompRefRel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compositional refinement relation defines a unit (element for the composition) of refinement relation, which specifies.  <a href="classilang_1_1_comp_ref_rel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_cosa__problem.html">Cosa_problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to store (and generate) the problem for cosa  <a href="classilang_1_1_cosa__problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_debug_log.html">DebugLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for enabling and disabling debug tags.  <a href="classilang_1_1_debug_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structilang_1_1_design_statistics.html">DesignStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">design statistics information  <a href="structilang_1_1_design_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structilang_1_1execute__result.html">execute_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the result from executing  <a href="structilang_1_1execute__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for expression, which is the basic type for variables, constraints, state update expressions, etc.  <a href="classilang_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_const.html">ExprConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for constant values (bool, bv, or memory). Constant should be terminating nodes in the AST.  <a href="classilang_1_1_expr_const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object for hashing <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. The hash value is the id of the symbol, which is supposed to be unique.  <a href="classilang_1_1_expr_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_mngr.html">ExprMngr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifier for AST trees by sharing nodes based on the hash value.  <a href="classilang_1_1_expr_mngr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op.html">ExprOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for operations, e.g. AND, OR, ADD, etc. Operations are non-terminating nodes in the AST.  <a href="classilang_1_1_expr_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_add.html">ExprOpAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned addition.  <a href="classilang_1_1_expr_op_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_and.html">ExprOpAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical AND operation "&amp;".  <a href="classilang_1_1_expr_op_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_app_func.html">ExprOpAppFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for apply uninterpreted function.  <a href="classilang_1_1_expr_op_app_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ashr.html">ExprOpAshr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for arithmetic right shifting a bit-vector.  <a href="classilang_1_1_expr_op_ashr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_compl.html">ExprOpCompl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary bit-wise complement "~". (bv only)  <a href="classilang_1_1_expr_op_compl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_concat.html">ExprOpConcat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for bitvector concatenation.  <a href="classilang_1_1_expr_op_concat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_div.html">ExprOpDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned division.  <a href="classilang_1_1_expr_op_div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_eq.html">ExprOpEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison EQ "==".  <a href="classilang_1_1_expr_op_eq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_extract.html">ExprOpExtract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for bitvector extraction.  <a href="classilang_1_1_expr_op_extract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_gt.html">ExprOpGt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison signed greater than "&gt;".  <a href="classilang_1_1_expr_op_gt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_imply.html">ExprOpImply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for logical imply.  <a href="classilang_1_1_expr_op_imply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ite.html">ExprOpIte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for if-then-else.  <a href="classilang_1_1_expr_op_ite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_load.html">ExprOpLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for memory load.  <a href="classilang_1_1_expr_op_load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_l_rotate.html">ExprOpLRotate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for left-rotate.  <a href="classilang_1_1_expr_op_l_rotate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_lshr.html">ExprOpLshr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for logical right shifting a bit-vector.  <a href="classilang_1_1_expr_op_lshr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_lt.html">ExprOpLt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison signed less than "&lt;".  <a href="classilang_1_1_expr_op_lt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_mul.html">ExprOpMul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned multiplication.  <a href="classilang_1_1_expr_op_mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_neg.html">ExprOpNeg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary negate operation "-".  <a href="classilang_1_1_expr_op_neg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_not.html">ExprOpNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary not operation "!". (bool only)  <a href="classilang_1_1_expr_op_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_or.html">ExprOpOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical OR operation "|".  <a href="classilang_1_1_expr_op_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_r_rotate.html">ExprOpRRotate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for right-rotate.  <a href="classilang_1_1_expr_op_r_rotate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_s_ext.html">ExprOpSExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for sign-extend.  <a href="classilang_1_1_expr_op_s_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_shl.html">ExprOpShl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for left shifting a bit-vector.  <a href="classilang_1_1_expr_op_shl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_s_mod.html">ExprOpSMod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for signed remainder.  <a href="classilang_1_1_expr_op_s_mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_s_rem.html">ExprOpSRem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for signed remainder.  <a href="classilang_1_1_expr_op_s_rem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_store.html">ExprOpStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for memory store.  <a href="classilang_1_1_expr_op_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_sub.html">ExprOpSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned subtraction.  <a href="classilang_1_1_expr_op_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ugt.html">ExprOpUgt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison unsigned greater than.  <a href="classilang_1_1_expr_op_ugt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ult.html">ExprOpUlt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison unsigned less than.  <a href="classilang_1_1_expr_op_ult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_u_rem.html">ExprOpURem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned remainder.  <a href="classilang_1_1_expr_op_u_rem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_xor.html">ExprOpXor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical XOR operation "^".  <a href="classilang_1_1_expr_op_xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_z_ext.html">ExprOpZExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for zero-extend.  <a href="classilang_1_1_expr_op_z_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a> (e.g. state var, var relation, constant, etc).  <a href="classilang_1_1_expr_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_var.html">ExprVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for variables (bool, bv, or mem). Variable should be the terminating nodes in the AST.  <a href="classilang_1_1_expr_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func.html">Func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for uninterpreted function.  <a href="classilang_1_1_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_flat_ila.html">FuncObjFlatIla</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for flatten ILA tree. There is currently a problem: this func obj calls duplInst which in turn uses rewriteExpr and rewriteExpr does not change the host of of state variables, so the flatten expression still has the host pointed to their original ILA. This is fine for Verilog Gen, which only depends on variable names to generate variables but may not be good enough for other purpose.  <a href="classilang_1_1_func_obj_flat_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_rewr_expr.html">FuncObjRewrExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for rewriting <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>.  <a href="classilang_1_1_func_obj_rewr_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_rewr_ila.html">FuncObjRewrIla</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for rewriting ILA tree.  <a href="classilang_1_1_func_obj_rewr_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_ref.html">FuncRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_func.html" title="The class for uninterpreted function.">Func</a> (uninterpreted function).  <a href="classilang_1_1_func_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_function_application_finder.html">FunctionApplicationFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of traversing to find the application of functions in an AST.  <a href="classilang_1_1_function_application_finder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_host_remove_restore.html">HostRemoveRestore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to remove and restore the host info This is useful as we want the ast with the same name generates the same z3 expr. This framework is based on an assumption that if we call z3 to create the variable of the same name multiple times they refer to the same one internally. FIXME: Need to check this assumption if we want to support other SMT solvers!  <a href="classilang_1_1_host_remove_restore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_i2_j_ser.html">I2JSer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for serializing an ILA model to JSON format.  <a href="classilang_1_1_i2_j_ser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila.html">Ila</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a> (ILA).  <a href="classilang_1_1_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila_ser_des_mngr.html">IlaSerDesMngr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class wrapper for the ILA portable Ser/Des interface.  <a href="classilang_1_1_ila_ser_des_mngr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila_sim.html">IlaSim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to generate SystemC simulator model from ILA model Example Use:  <a href="classilang_1_1_ila_sim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila_z3_unroller.html">IlaZ3Unroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of generating z3::expr for verification.  <a href="classilang_1_1_ila_z3_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr.html">Instr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for the Instruction. An <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a> object contains:  <a href="classilang_1_1_instr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_lvl_abs.html">InstrLvlAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of Instruction-Level Abstraction (ILA). An ILA contains:  <a href="classilang_1_1_instr_lvl_abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_ref.html">InstrRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a> (instruction).  <a href="classilang_1_1_instr_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_seq.html">InstrSeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction Sequencing does:  <a href="classilang_1_1_instr_seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_tran_edge.html">InstrTranEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction transition edge, includeing:  <a href="classilang_1_1_instr_tran_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_tran_node.html">InstrTranNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node for instruction-transition node, each node represent an instruction.  <a href="classilang_1_1_instr_tran_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inteface_directive_recorder.html">IntefaceDirectiveRecorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in Verilog Verification Target Generation for dealing with interface directives.  <a href="classilang_1_1_inteface_directive_recorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html">InterIlaUnroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for unrolling multiple ILAs. There are two ways of unrolling: ordered and unordered. Ordered unrolling assumes an ordered program template, despite that some may not exist in the final outcome. By default the state with the same name among ILAs is considered as the same shared state.  <a href="classilang_1_1_inter_ila_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_invariant_object.html">InvariantObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the invariant object, it needs smt-info to parse  <a href="classilang_1_1_invariant_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_j2_i_des.html">J2IDes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for deserializing an ILA model from JSON format.  <a href="classilang_1_1_j2_i_des.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_key_vec.html">KeyVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container that support key search and index access.  <a href="classilang_1_1_key_vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_key_vec_it.html">KeyVecIt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudo-iterator for the key-search vector.  <a href="classilang_1_1_key_vec_it.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_legacy_bmc.html">LegacyBmc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified bounded model checking engine for ILAs.  <a href="classilang_1_1_legacy_bmc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_log_initter.html">LogInitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-time class for initializing GLog.  <a href="classilang_1_1_log_initter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_map_set.html">MapSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map for sets.  <a href="classilang_1_1_map_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_memory_model.html">MemoryModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for memory models.  <a href="classilang_1_1_memory_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_mem_val.html">MemVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing memory (array) values.  <a href="classilang_1_1_mem_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_mono_unroll.html">MonoUnroll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application class for unrolling the ILA as a monolithic transition system.  <a href="classilang_1_1_mono_unroll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_nested_mem_addr_data_avoider.html">NestedMemAddrDataAvoider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of traversing to avoid nested memory access in address.  <a href="classilang_1_1_nested_mem_addr_data_avoider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basest type in the ILA structure. It can be either <a class="el" href="classilang_1_1_ast.html" title="The class for the Abstract Syntax Tree. An Ast object can be an expression or function definition (in...">Ast</a>, <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>, or <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a>.  <a href="classilang_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_path_unroll.html">PathUnroll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application class for unrolling a path of instruction sequence.  <a href="classilang_1_1_path_unroll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_refinement_map.html">RefinementMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement mapping defines how to map micro-architectural states to architectural states for comparison.  <a href="classilang_1_1_refinement_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_relation_map.html">RelationMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relation mapping defines how arch states of two models are mapped, i.e., state mapping.  <a href="classilang_1_1_relation_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sc.html">Sc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO.  <a href="classilang_1_1_sc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sc_trace_step.html">ScTraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO trace step.  <a href="classilang_1_1_sc_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_base.html">SignalInfoBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold signal info.  <a href="classilang_1_1_signal_info_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_port.html">SignalInfoPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to convert port to signal info.  <a href="classilang_1_1_signal_info_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_reg.html">SignalInfoReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to convert reg to signal info.  <a href="classilang_1_1_signal_info_reg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_wire.html">SignalInfoWire</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to convert wire to signal info.  <a href="classilang_1_1_signal_info_wire.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort.html">Sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for sort (type for expr, and the range/domain of functions).  <a href="classilang_1_1_sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_bool.html">SortBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of Boolean <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>.  <a href="classilang_1_1_sort_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_bv.html">SortBv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of bit-vector <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>.  <a href="classilang_1_1_sort_bv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_mem.html">SortMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of memory (array) <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>.  <a href="classilang_1_1_sort_mem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_ref.html">SortRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a> (type for different AST nodes).  <a href="classilang_1_1_sort_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_state_mapping_directive_recorder.html">StateMappingDirectiveRecorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to handle state mapping directives in the refinement relations  <a href="classilang_1_1_state_mapping_directive_recorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_symbol.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symbol is the name and ID of an object. Every object has an unique symbol.  <a href="classilang_1_1_symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_synth_abs_converter.html">SynthAbsConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for converting an abstraction from the synthesis engine to an ILA model.  <a href="classilang_1_1_synth_abs_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_trace_step.html">TraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for trace step (an instance of instruction) As in the unrolling, there may be multiple instances of the same instructions, so we have the trace steps.  <a href="classilang_1_1_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_tso.html">Tso</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO.  <a href="classilang_1_1_tso.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_tso_trace_step.html">TsoTraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO trace step.  <a href="classilang_1_1_tso_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_unroller.html">Unroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for unrolling ILA execution in different settings.  <a href="classilang_1_1_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base type for constant value.  <a href="classilang_1_1_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_var_extractor.html">VarExtractor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_var_use_finder.html">VarUseFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of finding variable uses. So that we don't need to create pi variables for unused state variables. FIXME: currently there is no need to make a class for it, but in the future it is possible to use a hash table to avoid traverse the same sub-tree twice.  <a href="classilang_1_1_var_use_finder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_analyzer.html">VerilogAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for Verilog analysis.  <a href="classilang_1_1_verilog_analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_analyzer_base.html">VerilogAnalyzerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classilang_1_1_verilog_analyzer_base.html" title="VerilogAnalyzerBase should never be instantiated, only used as a pointer type in class VerilogInfo.">VerilogAnalyzerBase</a> should never be instantiated, only used as a pointer type in class <a class="el" href="classilang_1_1_verilog_info.html" title="The class that invoke the analyzer.">VerilogInfo</a>.  <a href="classilang_1_1_verilog_analyzer_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_constant_expr_eval.html">VerilogConstantExprEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class to convert a constant expr to an integer number.  <a href="classilang_1_1_verilog_constant_expr_eval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_generator.html">VerilogGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Verilog Generator.  <a href="classilang_1_1_verilog_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_generator_base.html">VerilogGeneratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of <a class="el" href="classilang_1_1_verilog_generator.html" title="Class of Verilog Generator.">VerilogGenerator</a>.  <a href="classilang_1_1_verilog_generator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_info.html">VerilogInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class that invoke the analyzer.  <a href="classilang_1_1_verilog_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_modifier.html">VerilogModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the class for modification to verilog  <a href="classilang_1_1_verilog_modifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_verification_target_generator.html">VerilogVerificationTargetGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structilang_1_1_vlg_abs_mem.html">VlgAbsMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a struct to store abstract memory  <a href="structilang_1_1_vlg_abs_mem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_sgl_tgt_gen.html">VlgSglTgtGen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a target (just the invairant or for an instruction)  <a href="classilang_1_1_vlg_sgl_tgt_gen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_sgl_tgt_gen___cosa.html">VlgSglTgtGen_Cosa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to interface w. COSA  <a href="classilang_1_1_vlg_sgl_tgt_gen___cosa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_sgl_tgt_gen___jasper.html">VlgSglTgtGen_Jasper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verilog Verification Target Generator &ndash; for JasperGold Unlike for cosa, we don't need a separate file although we do have some ...  <a href="classilang_1_1_vlg_sgl_tgt_gen___jasper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_sgl_tgt_gen___yosys.html">VlgSglTgtGen_Yosys</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to interface w. Yosys  <a href="classilang_1_1_vlg_sgl_tgt_gen___yosys.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structilang_1_1_vlg_tgt_supplementary_info.html">VlgTgtSupplementaryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the class to hold supplementary information  <a href="structilang_1_1_vlg_tgt_supplementary_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_verif_tgt_gen.html">VlgVerifTgtGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_verif_tgt_gen_base.html">VlgVerifTgtGenBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classilang_1_1_vlg_verif_tgt_gen_base.html" title="VlgVerifTgtGenBase: do nothing, should not instantiate.">VlgVerifTgtGenBase</a>: do nothing, should not instantiate.  <a href="classilang_1_1_vlg_verif_tgt_gen_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_yosys__problem.html">Yosys_problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to store (and generate) the problem for Yosys  <a href="classilang_1_1_yosys__problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_z3_expr_adapter.html">Z3ExprAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for generating z3 expression from an ILA.  <a href="classilang_1_1_z3_expr_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="memItemLeft" align="right" valign="top"><a id="a7c4196c72e53ea4df4b7861af7bc3bce"></a>
typedef <a class="el" href="classilang_1_1_expr.html#a85952b6a34620c4c8cab6bac9c9fdf8c">Expr::ExprPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a></td></tr>
<tr class="memdesc:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="memItemLeft" align="right" valign="top"><a id="a95d222bcc4d46261cbf6dbc18a3f5e11"></a>
typedef <a class="el" href="classilang_1_1_expr.html#a17efc8282f647681d37cd4c78928aa01">Expr::ExprPtrVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a95d222bcc4d46261cbf6dbc18a3f5e11">ExprPtrVec</a></td></tr>
<tr class="memdesc:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e6475e04844bcad9c380aac0b215c"><td class="memItemLeft" align="right" valign="top"><a id="ad40e6475e04844bcad9c380aac0b215c"></a>
typedef std::unordered_map&lt; const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad40e6475e04844bcad9c380aac0b215c">ExprMap</a></td></tr>
<tr class="memdesc:ad40e6475e04844bcad9c380aac0b215c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for mapping between <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:ad40e6475e04844bcad9c380aac0b215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54732171848dbcb975458e689024a04c"><td class="memItemLeft" align="right" valign="top"><a id="a54732171848dbcb975458e689024a04c"></a>
typedef std::unordered_set&lt; <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a54732171848dbcb975458e689024a04c">ExprSet</a></td></tr>
<tr class="memdesc:a54732171848dbcb975458e689024a04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a54732171848dbcb975458e689024a04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6140a3823254564a0e81db8b3afea25c"><td class="memItemLeft" align="right" valign="top"><a id="a6140a3823254564a0e81db8b3afea25c"></a>
typedef <a class="el" href="classilang_1_1_func.html#a91aa192ceb8b9025423fdb95c8429282">Func::FuncPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6140a3823254564a0e81db8b3afea25c">FuncPtr</a></td></tr>
<tr class="memdesc:a6140a3823254564a0e81db8b3afea25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_func.html" title="The class for uninterpreted function.">Func</a>. <br /></td></tr>
<tr class="separator:a6140a3823254564a0e81db8b3afea25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01073336878d60a231f4fe96d45ab55"><td class="memItemLeft" align="right" valign="top"><a id="ae01073336878d60a231f4fe96d45ab55"></a>
typedef <a class="el" href="classilang_1_1_sort.html#a8b9cc5e381404211a1c0423327866d3b">Sort::SortPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae01073336878d60a231f4fe96d45ab55">SortPtr</a></td></tr>
<tr class="memdesc:ae01073336878d60a231f4fe96d45ab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for storing/passing <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>. <br /></td></tr>
<tr class="separator:ae01073336878d60a231f4fe96d45ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="memItemLeft" align="right" valign="top"><a id="ad512edf5ea3912c37cb9c9a4a47d09d0"></a>
typedef <a class="el" href="classilang_1_1_value.html#af7f5423825f03fdb5f62d2598778d644">Value::ValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad512edf5ea3912c37cb9c9a4a47d09d0">ValPtr</a></td></tr>
<tr class="memdesc:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_value.html" title="The base type for constant value.">Value</a>. <br /></td></tr>
<tr class="separator:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dabeb8fdac011892c311e074696b570"><td class="memItemLeft" align="right" valign="top"><a id="a8dabeb8fdac011892c311e074696b570"></a>
typedef <a class="el" href="classilang_1_1_bool_val.html#aba4dff009d7d7f6c0a879312dbb23ba3">BoolVal::BoolValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8dabeb8fdac011892c311e074696b570">BoolValPtr</a></td></tr>
<tr class="memdesc:a8dabeb8fdac011892c311e074696b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_bool_val.html" title="The container for representing Boolean values.">BoolVal</a>. <br /></td></tr>
<tr class="separator:a8dabeb8fdac011892c311e074696b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b38d4e87534db4ff8b793d11d1d950"><td class="memItemLeft" align="right" valign="top"><a id="af9b38d4e87534db4ff8b793d11d1d950"></a>
typedef <a class="el" href="classilang_1_1_bv_val.html#a1df12ef757e3e9a0e4ca1daaccdccfd6">BvVal::BvValType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af9b38d4e87534db4ff8b793d11d1d950">BvValType</a></td></tr>
<tr class="memdesc:af9b38d4e87534db4ff8b793d11d1d950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for storing <a class="el" href="classilang_1_1_bv_val.html" title="The container for representing Bitvector values.">BvVal</a>. <br /></td></tr>
<tr class="separator:af9b38d4e87534db4ff8b793d11d1d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a892f6286748cb7548429984d840752"><td class="memItemLeft" align="right" valign="top"><a id="a6a892f6286748cb7548429984d840752"></a>
typedef <a class="el" href="classilang_1_1_bv_val.html#a07cd315cb7e6d40ec7fef2b00989b074">BvVal::BvValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6a892f6286748cb7548429984d840752">BvValPtr</a></td></tr>
<tr class="memdesc:a6a892f6286748cb7548429984d840752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_bv_val.html" title="The container for representing Bitvector values.">BvVal</a>. <br /></td></tr>
<tr class="separator:a6a892f6286748cb7548429984d840752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="memItemLeft" align="right" valign="top"><a id="a4fd677b2cf7cb4e83a1e81f35e9aec6b"></a>
typedef <a class="el" href="classilang_1_1_mem_val.html#a9a2bf21ab1aa0d15fcb9024025a1487e">MemVal::MemValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4fd677b2cf7cb4e83a1e81f35e9aec6b">MemValPtr</a></td></tr>
<tr class="memdesc:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_mem_val.html" title="The container for representing memory (array) values.">MemVal</a>. <br /></td></tr>
<tr class="separator:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63554514c4dc658062d446051c78882"><td class="memItemLeft" align="right" valign="top"><a id="aa63554514c4dc658062d446051c78882"></a>
typedef <a class="el" href="classilang_1_1_mem_val.html#a45c846cad5311f4f5de37a8c681e270a">MemVal::MemValMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa63554514c4dc658062d446051c78882">MemValMap</a></td></tr>
<tr class="memdesc:aa63554514c4dc658062d446051c78882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing the address/data mapping. <br /></td></tr>
<tr class="separator:aa63554514c4dc658062d446051c78882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a114dcaa252083440129309151528"><td class="memItemLeft" align="right" valign="top"><a id="a540a114dcaa252083440129309151528"></a>
typedef <a class="el" href="classilang_1_1_refinement_map.html#ab988c650cef076c777dd0200e8dab51f">RefinementMap::RefPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a540a114dcaa252083440129309151528">RefPtr</a></td></tr>
<tr class="memdesc:a540a114dcaa252083440129309151528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the refinement mapping. <br /></td></tr>
<tr class="separator:a540a114dcaa252083440129309151528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="memItemLeft" align="right" valign="top"><a id="adca57fadf3c1f00dba124eb1ec56e6e9"></a>
typedef <a class="el" href="classilang_1_1_relation_map.html#adfdefb173e77fc29073c233aa3ccdbd2">RelationMap::RelPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adca57fadf3c1f00dba124eb1ec56e6e9">RelPtr</a></td></tr>
<tr class="memdesc:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the relation mapping. <br /></td></tr>
<tr class="separator:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="memItemLeft" align="right" valign="top"><a id="a3c2c096b87ad7a9475c5a32315c18ba6"></a>
typedef <a class="el" href="classilang_1_1_comp_ref_rel.html#a9081b437a14b3a2edef9d30b000ea535">CompRefRel::CrrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a3c2c096b87ad7a9475c5a32315c18ba6">CrrPtr</a></td></tr>
<tr class="memdesc:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the compositional relation mapping. <br /></td></tr>
<tr class="separator:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4eee919aa24fff882d03a48d733c19"><td class="memItemLeft" align="right" valign="top"><a id="adc4eee919aa24fff882d03a48d733c19"></a>
typedef std::vector&lt; z3::expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc4eee919aa24fff882d03a48d733c19">Z3ExprVec</a></td></tr>
<tr class="memdesc:adc4eee919aa24fff882d03a48d733c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type for z3 expression. <br /></td></tr>
<tr class="separator:adc4eee919aa24fff882d03a48d733c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9ddf66d424d9d9544db761963a5836"><td class="memItemLeft" align="right" valign="top"><a id="aca9ddf66d424d9d9544db761963a5836"></a>
typedef std::shared_ptr&lt; <a class="el" href="namespaceilang.html#adc4eee919aa24fff882d03a48d733c19">Z3ExprVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aca9ddf66d424d9d9544db761963a5836">Z3ExprVecPtr</a></td></tr>
<tr class="memdesc:aca9ddf66d424d9d9544db761963a5836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer for the z3 expression vector. <br /></td></tr>
<tr class="separator:aca9ddf66d424d9d9544db761963a5836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e34b145b7ce30f509c336c32013c097"><td class="memItemLeft" align="right" valign="top"><a id="a9e34b145b7ce30f509c336c32013c097"></a>
typedef <a class="el" href="classilang_1_1_key_vec.html">KeyVec</a>&lt; <a class="el" href="classilang_1_1_symbol.html">Symbol</a>, z3::expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9e34b145b7ce30f509c336c32013c097">Z3ExprMap</a></td></tr>
<tr class="memdesc:a9e34b145b7ce30f509c336c32013c097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map type for z3 expression. <br /></td></tr>
<tr class="separator:a9e34b145b7ce30f509c336c32013c097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aa5111edd013874f3cfd7de9bf11bc"><td class="memItemLeft" align="right" valign="top"><a id="a96aa5111edd013874f3cfd7de9bf11bc"></a>
typedef std::shared_ptr&lt; <a class="el" href="namespaceilang.html#a9e34b145b7ce30f509c336c32013c097">Z3ExprMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a96aa5111edd013874f3cfd7de9bf11bc">Z3ExprMapPtr</a></td></tr>
<tr class="memdesc:a96aa5111edd013874f3cfd7de9bf11bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer for the z3 expression map. <br /></td></tr>
<tr class="separator:a96aa5111edd013874f3cfd7de9bf11bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee5051111191e26d672ae214bcf3e1b"><td class="memItemLeft" align="right" valign="top"><a id="a4ee5051111191e26d672ae214bcf3e1b"></a>
typedef <a class="el" href="classilang_1_1_expr_mngr.html#ad35ebf0cecad6f10877667b766bdfac1">ExprMngr::ExprMngrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4ee5051111191e26d672ae214bcf3e1b">ExprMngrPtr</a></td></tr>
<tr class="memdesc:a4ee5051111191e26d672ae214bcf3e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing shared ast simplifier. <br /></td></tr>
<tr class="separator:a4ee5051111191e26d672ae214bcf3e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88a19312ae653d687a0d1207bb284f6"><td class="memItemLeft" align="right" valign="top"><a id="af88a19312ae653d687a0d1207bb284f6"></a>
typedef <a class="el" href="classilang_1_1_instr.html#af43ebb1fe223b369e42b5600f902b4b4">Instr::InstrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af88a19312ae653d687a0d1207bb284f6">InstrPtr</a></td></tr>
<tr class="memdesc:af88a19312ae653d687a0d1207bb284f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>. <br /></td></tr>
<tr class="separator:af88a19312ae653d687a0d1207bb284f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80683459249860b96e73997182db5309"><td class="memItemLeft" align="right" valign="top"><a id="a80683459249860b96e73997182db5309"></a>
typedef <a class="el" href="classilang_1_1_instr.html#a6e26c0331fe17f1267ec1272b7dbddfa">Instr::InstrCnstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a80683459249860b96e73997182db5309">InstrCnstPtr</a></td></tr>
<tr class="memdesc:a80683459249860b96e73997182db5309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for read-only use of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>. <br /></td></tr>
<tr class="separator:a80683459249860b96e73997182db5309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e6555f156373812f16030b98c42e65"><td class="memItemLeft" align="right" valign="top"><a id="a35e6555f156373812f16030b98c42e65"></a>
typedef std::vector&lt; <a class="el" href="namespaceilang.html#af88a19312ae653d687a0d1207bb284f6">InstrPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a35e6555f156373812f16030b98c42e65">InstrVec</a></td></tr>
<tr class="memdesc:a35e6555f156373812f16030b98c42e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>. <br /></td></tr>
<tr class="separator:a35e6555f156373812f16030b98c42e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b30fdf347e493b3937143da05d1a72"><td class="memItemLeft" align="right" valign="top"><a id="ad1b30fdf347e493b3937143da05d1a72"></a>
typedef <a class="el" href="classilang_1_1_instr_lvl_abs.html#a743fd98e5ad145d70cb0dabf8db0007c">InstrLvlAbs::InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a></td></tr>
<tr class="memdesc:ad1b30fdf347e493b3937143da05d1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a>. <br /></td></tr>
<tr class="separator:ad1b30fdf347e493b3937143da05d1a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc86156b73aa1a4b6369645e9b96ff19"><td class="memItemLeft" align="right" valign="top"><a id="adc86156b73aa1a4b6369645e9b96ff19"></a>
typedef <a class="el" href="classilang_1_1_instr_lvl_abs.html#a57464e2e6a69327715fa88963ebfb282">InstrLvlAbs::InstrLvlAbsCnstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc86156b73aa1a4b6369645e9b96ff19">InstrLvlAbsCnstPtr</a></td></tr>
<tr class="memdesc:adc86156b73aa1a4b6369645e9b96ff19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for read-only usage of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a>. <br /></td></tr>
<tr class="separator:adc86156b73aa1a4b6369645e9b96ff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e780d7b16cb21d2c10f955c504e7356"><td class="memItemLeft" align="right" valign="top"><a id="a4e780d7b16cb21d2c10f955c504e7356"></a>
typedef std::map&lt; <a class="el" href="namespaceilang.html#adc86156b73aa1a4b6369645e9b96ff19">InstrLvlAbsCnstPtr</a>, <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4e780d7b16cb21d2c10f955c504e7356">CnstIlaMap</a></td></tr>
<tr class="memdesc:a4e780d7b16cb21d2c10f955c504e7356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a mapping from constant ILA ptr to ILA ptr. <br /></td></tr>
<tr class="separator:a4e780d7b16cb21d2c10f955c504e7356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc547f597d2a58cf82dfe756fe092d86"><td class="memItemLeft" align="right" valign="top"><a id="adc547f597d2a58cf82dfe756fe092d86"></a>
typedef <a class="el" href="classilang_1_1_object.html#af23d3767cfbc8cb9312281cbfa4aae48">Object::ObjPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc547f597d2a58cf82dfe756fe092d86">ObjPtr</a></td></tr>
<tr class="memdesc:adc547f597d2a58cf82dfe756fe092d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_object.html" title="The basest type in the ILA structure. It can be either Ast, Instr, or InstrLvlAbs.">Object</a>. <br /></td></tr>
<tr class="separator:adc547f597d2a58cf82dfe756fe092d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7c382e8a666b516fc761b0ce8bff8"><td class="memItemLeft" align="right" valign="top"><a id="a61e7c382e8a666b516fc761b0ce8bff8"></a>
typedef <a class="el" href="classilang_1_1_instr_seq.html#a37dd168ce5d95507eb7bf53455d79b80">InstrSeq::InstrSeqPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a61e7c382e8a666b516fc761b0ce8bff8">InstrSeqPtr</a></td></tr>
<tr class="memdesc:a61e7c382e8a666b516fc761b0ce8bff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around <a class="el" href="classilang_1_1_instr_seq.html" title="Instruction Sequencing does:">InstrSeq</a>. <br /></td></tr>
<tr class="separator:a61e7c382e8a666b516fc761b0ce8bff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e2a4ef111b96f327b76f11e86b01a"><td class="memItemLeft" align="right" valign="top"><a id="a784e2a4ef111b96f327b76f11e86b01a"></a>
typedef <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a784e2a4ef111b96f327b76f11e86b01a">Z3AdapterHash</a></td></tr>
<tr class="memdesc:a784e2a4ef111b96f327b76f11e86b01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object for hashing <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a> in generating z3 expression. <br /></td></tr>
<tr class="separator:a784e2a4ef111b96f327b76f11e86b01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1d2afe4c879a45329d57affe54a1db"><td class="memItemLeft" align="right" valign="top"><a id="acc1d2afe4c879a45329d57affe54a1db"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a></td></tr>
<tr class="memdesc:acc1d2afe4c879a45329d57affe54a1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for numerics. NOTE: SHOULD BE SYNCED WITH BvValType!! <br /></td></tr>
<tr class="separator:acc1d2afe4c879a45329d57affe54a1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e72f6051594b2a8c58f6ad6ee59df1"><td class="memItemLeft" align="right" valign="top"><a id="ab0e72f6051594b2a8c58f6ad6ee59df1"></a>
typedef <a class="el" href="classilang_1_1_synth_abs_converter.html#a4ea7491df29005572c22aae8786db092">SynthAbsConverter::SynthAbsConverterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab0e72f6051594b2a8c58f6ad6ee59df1">SynthAbsConverterPtr</a></td></tr>
<tr class="memdesc:ab0e72f6051594b2a8c58f6ad6ee59df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_synth_abs_converter.html" title="The class for converting an abstraction from the synthesis engine to an ILA model.">SynthAbsConverter</a>. <br /></td></tr>
<tr class="separator:ab0e72f6051594b2a8c58f6ad6ee59df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a0fa3acbb99035c33836ee55b0c672"><td class="memItemLeft" align="right" valign="top"><a id="af2a0fa3acbb99035c33836ee55b0c672"></a>
typedef <a class="el" href="classilang_1_1_i2_j_ser.html#ad1e0aaa7242a3020763523ebaeff034f">I2JSer::I2JSerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af2a0fa3acbb99035c33836ee55b0c672">I2JSerPtr</a></td></tr>
<tr class="memdesc:af2a0fa3acbb99035c33836ee55b0c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_i2_j_ser.html" title="The class for serializing an ILA model to JSON format.">I2JSer</a>. <br /></td></tr>
<tr class="separator:af2a0fa3acbb99035c33836ee55b0c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c41ab4ec19b72eb84fe175e058c40ae"><td class="memItemLeft" align="right" valign="top"><a id="a0c41ab4ec19b72eb84fe175e058c40ae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>json</b> = nlohmann::json</td></tr>
<tr class="separator:a0c41ab4ec19b72eb84fe175e058c40ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d649149559c0d42b4315c15ec3023c0"><td class="memItemLeft" align="right" valign="top"><a id="a1d649149559c0d42b4315c15ec3023c0"></a>
typedef <a class="el" href="classilang_1_1_j2_i_des.html#a9c4de6792d4a106a0dc40451fddf637c">J2IDes::J2IDesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1d649149559c0d42b4315c15ec3023c0">J2IDesPtr</a></td></tr>
<tr class="memdesc:a1d649149559c0d42b4315c15ec3023c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_j2_i_des.html" title="The class for deserializing an ILA model from JSON format.">J2IDes</a>. <br /></td></tr>
<tr class="separator:a1d649149559c0d42b4315c15ec3023c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3529ea370d3252b9e44e20b53532e"><td class="memItemLeft" align="right" valign="top"><a id="a6ae3529ea370d3252b9e44e20b53532e"></a>
typedef <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VerilogGenHash</b></td></tr>
<tr class="separator:a6ae3529ea370d3252b9e44e20b53532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6ec2515ae3e70a4fdc7f5ea2afa02759"><td class="memItemLeft" align="right" valign="top"><a id="a6ec2515ae3e70a4fdc7f5ea2afa02759"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6ec2515ae3e70a4fdc7f5ea2afa02759">AST_UID_SORT</a> { <b>BOOL</b> = 1, 
<b>BV</b>, 
<b>MEM</b>
 }</td></tr>
<tr class="memdesc:a6ec2515ae3e70a4fdc7f5ea2afa02759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified ID for Sort. <br /></td></tr>
<tr class="separator:a6ec2515ae3e70a4fdc7f5ea2afa02759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e1c5a9029426dc0794c4c74c675cea"><td class="memItemLeft" align="right" valign="top"><a id="aa8e1c5a9029426dc0794c4c74c675cea"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa8e1c5a9029426dc0794c4c74c675cea">AST_UID_EXPR</a> { <b>VAR</b> = 1, 
<b>CONST</b>, 
<b>OP</b>
 }</td></tr>
<tr class="memdesc:aa8e1c5a9029426dc0794c4c74c675cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified ID for Expr type. <br /></td></tr>
<tr class="separator:aa8e1c5a9029426dc0794c4c74c675cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d51cc1a5df5198d10d1db7c5beeac42"><td class="memItemLeft" align="right" valign="top"><a id="a4d51cc1a5df5198d10d1db7c5beeac42"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4d51cc1a5df5198d10d1db7c5beeac42">AST_UID_EXPR_OP</a> { <br />
&#160;&#160;<b>INVALID</b> = 0, 
<b>NEG</b>, 
<b>NOT</b>, 
<b>COMPL</b>, 
<br />
&#160;&#160;<b>AND</b>, 
<b>OR</b>, 
<b>XOR</b>, 
<b>SHL</b>, 
<br />
&#160;&#160;<b>ASHR</b>, 
<b>LSHR</b>, 
<b>ADD</b>, 
<b>SUB</b>, 
<br />
&#160;&#160;<b>MUL</b>, 
<b>EQ</b>, 
<b>LT</b>, 
<b>GT</b>, 
<br />
&#160;&#160;<b>ULT</b>, 
<b>UGT</b>, 
<b>LOAD</b>, 
<b>STORE</b>, 
<br />
&#160;&#160;<b>CONCAT</b>, 
<b>EXTRACT</b>, 
<b>ZEXT</b>, 
<b>SEXT</b>, 
<br />
&#160;&#160;<b>APP_FUNC</b>, 
<b>IMPLY</b>, 
<b>ITE</b>, 
<b>DIV</b>, 
<br />
&#160;&#160;<b>LROTATE</b>, 
<b>RROTATE</b>, 
<b>SREM</b>, 
<b>UREM</b>, 
<br />
&#160;&#160;<b>SMOD</b>
<br />
 }</td></tr>
<tr class="memdesc:a4d51cc1a5df5198d10d1db7c5beeac42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified ID for ExprOp. <br /></td></tr>
<tr class="separator:a4d51cc1a5df5198d10d1db7c5beeac42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e20af889c24c84475198e2db9937cf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2e20af889c24c84475198e2db9937cf7">DEFAULT_UPDATE_METHOD</a> { <b>OLD_VALUE</b> = 0, 
<b>NONDET_VALUE</b> = 1
 }</td></tr>
<tr class="separator:a2e20af889c24c84475198e2db9937cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dc990a0af528177f6f90b63bd208c7"><td class="memItemLeft" align="right" valign="top"><a id="ab4dc990a0af528177f6f90b63bd208c7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab4dc990a0af528177f6f90b63bd208c7">AccessType</a> { <b>READ</b>, 
<b>WRITE</b>, 
<b>EITHER</b>
 }</td></tr>
<tr class="memdesc:ab4dc990a0af528177f6f90b63bd208c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of state read or write. <br /></td></tr>
<tr class="separator:ab4dc990a0af528177f6f90b63bd208c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb374202f0c669bea0a49b87d8dee143"><td class="memItemLeft" align="right" valign="top"><a id="aeb374202f0c669bea0a49b87d8dee143"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeb374202f0c669bea0a49b87d8dee143">KeyVecItVal</a> { <b>END</b>, 
<b>FOUND</b>
 }</td></tr>
<tr class="memdesc:aeb374202f0c669bea0a49b87d8dee143"><td class="mdescLeft">&#160;</td><td class="mdescRight">KeyVecItVal. <br /></td></tr>
<tr class="separator:aeb374202f0c669bea0a49b87d8dee143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3372e18c965cab7e146d01c376a24a"><td class="memItemLeft" align="right" valign="top"><a id="a6b3372e18c965cab7e146d01c376a24a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6b3372e18c965cab7e146d01c376a24a">redirect_t</a> { <b>NONE</b> = 0, 
<b>STDOUT</b> = 1, 
<b>STDERR</b> = 2, 
<b>BOTH</b> = 3
 }</td></tr>
<tr class="memdesc:a6b3372e18c965cab7e146d01c376a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of redirect <br /></td></tr>
<tr class="separator:a6b3372e18c965cab7e146d01c376a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1a3284ef090db4d828f6635c7d7572a0"><td class="memItemLeft" align="right" valign="top"><a id="a1a3284ef090db4d828f6635c7d7572a0"></a>
<a class="el" href="namespaceilang.html#a6ec2515ae3e70a4fdc7f5ea2afa02759">AST_UID_SORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1a3284ef090db4d828f6635c7d7572a0">GetUidSort</a> (const <a class="el" href="namespaceilang.html#ae01073336878d60a231f4fe96d45ab55">SortPtr</a> &amp;sort)</td></tr>
<tr class="memdesc:a1a3284ef090db4d828f6635c7d7572a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the AST_UID_SORT of the given <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>. <br /></td></tr>
<tr class="separator:a1a3284ef090db4d828f6635c7d7572a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc47efbf1e7df0879497df80b32d909"><td class="memItemLeft" align="right" valign="top"><a id="a6bc47efbf1e7df0879497df80b32d909"></a>
<a class="el" href="namespaceilang.html#aa8e1c5a9029426dc0794c4c74c675cea">AST_UID_EXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6bc47efbf1e7df0879497df80b32d909">GetUidExpr</a> (const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;expr)</td></tr>
<tr class="memdesc:a6bc47efbf1e7df0879497df80b32d909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the AST_UID_EXPR of the given <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a6bc47efbf1e7df0879497df80b32d909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0e6cc9a9703c578f6df3959718f98"><td class="memItemLeft" align="right" valign="top"><a id="ae4e0e6cc9a9703c578f6df3959718f98"></a>
<a class="el" href="namespaceilang.html#a4d51cc1a5df5198d10d1db7c5beeac42">AST_UID_EXPR_OP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae4e0e6cc9a9703c578f6df3959718f98">GetUidExprOp</a> (const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;expr)</td></tr>
<tr class="memdesc:ae4e0e6cc9a9703c578f6df3959718f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the AST_UID_EXPR_OP of the given <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a> (must be <a class="el" href="classilang_1_1_expr_op.html" title="Expression for operations, e.g. AND, OR, ADD, etc. Operations are non-terminating nodes in the AST.">ExprOp</a>). <br /></td></tr>
<tr class="separator:ae4e0e6cc9a9703c578f6df3959718f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed520a7d8e159cf7188680647cede3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7eed520a7d8e159cf7188680647cede3">CheckDeterminism</a> (const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;model_ptr_)</td></tr>
<tr class="separator:a7eed520a7d8e159cf7188680647cede3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388d56a6951f3e383bcdf0e39a672720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a388d56a6951f3e383bcdf0e39a672720">CheckCompleteness</a> (const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;model_ptr_)</td></tr>
<tr class="separator:a388d56a6951f3e383bcdf0e39a672720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbb2022a842f23f36ef624986ea61bd"><td class="memItemLeft" align="right" valign="top"><a id="aafbb2022a842f23f36ef624986ea61bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aafbb2022a842f23f36ef624986ea61bd">CompleteModel</a> (const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;model_ptr_, <a class="el" href="namespaceilang.html#a2e20af889c24c84475198e2db9937cf7">DEFAULT_UPDATE_METHOD</a> dum)</td></tr>
<tr class="memdesc:aafbb2022a842f23f36ef624986ea61bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a default update method to complete model. <br /></td></tr>
<tr class="separator:aafbb2022a842f23f36ef624986ea61bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ee876398e1809694900f2555cd6ad9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a41ee876398e1809694900f2555cd6ad9">CheckEqSameArch</a> (const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;a, const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;b, bool update=true)</td></tr>
<tr class="memdesc:a41ee876398e1809694900f2555cd6ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two ILAs have an exact same architecture, i.e., at the highest level of hierarchy.  <a href="namespaceilang.html#a41ee876398e1809694900f2555cd6ad9">More...</a><br /></td></tr>
<tr class="separator:a41ee876398e1809694900f2555cd6ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656b2f08edc6fdf198af1ac54756b6ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a656b2f08edc6fdf198af1ac54756b6ca">CheckEqSameMicroArch</a> (const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;a, const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;b, bool update=true)</td></tr>
<tr class="memdesc:a656b2f08edc6fdf198af1ac54756b6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two ILAs have an exact same micro-architecture. That is, they have a same architecture at every level in the hierarchy.  <a href="namespaceilang.html#a656b2f08edc6fdf198af1ac54756b6ca">More...</a><br /></td></tr>
<tr class="separator:a656b2f08edc6fdf198af1ac54756b6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38808a9aed62a8c4a6917621c9318d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a38808a9aed62a8c4a6917621c9318d6e">LogLevel</a> (const int &amp;lvl)</td></tr>
<tr class="memdesc:a38808a9aed62a8c4a6917621c9318d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimun log level. Log messages at or above this level will be logged. (Default: 0)  <a href="namespaceilang.html#a38808a9aed62a8c4a6917621c9318d6e">More...</a><br /></td></tr>
<tr class="separator:a38808a9aed62a8c4a6917621c9318d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="memItemLeft" align="right" valign="top"><a id="a04b0d31076d694adcb6b1ee0a475c9dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a04b0d31076d694adcb6b1ee0a475c9dd">LogPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path for log file. If specified, logfiles are written into this directory instead of the default logging directory (/tmp). <br /></td></tr>
<tr class="separator:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d33dbd65f2036041b06be22c830592b"><td class="memItemLeft" align="right" valign="top"><a id="a7d33dbd65f2036041b06be22c830592b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7d33dbd65f2036041b06be22c830592b">LogToErr</a> (bool to_err)</td></tr>
<tr class="memdesc:a7d33dbd65f2036041b06be22c830592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe log to stderr. Log messages to stderr instead of logfiles, if set to 1. <br /></td></tr>
<tr class="separator:a7d33dbd65f2036041b06be22c830592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596c444f0d40287ee7b91263d6ab91c"><td class="memItemLeft" align="right" valign="top"><a id="af596c444f0d40287ee7b91263d6ab91c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af596c444f0d40287ee7b91263d6ab91c">EnableDebug</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:af596c444f0d40287ee7b91263d6ab91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a debug tag. <br /></td></tr>
<tr class="separator:af596c444f0d40287ee7b91263d6ab91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="memItemLeft" align="right" valign="top"><a id="a7b96e3e4622bcefd2d1159766a2df3d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7b96e3e4622bcefd2d1159766a2df3d8">DisableDebug</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a debug tag. <br /></td></tr>
<tr class="separator:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48e47567031b28aa1b58b82e40f60d1"><td class="memItemLeft" align="right" valign="top"><a id="ad48e47567031b28aa1b58b82e40f60d1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad48e47567031b28aa1b58b82e40f60d1">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:ad48e47567031b28aa1b58b82e40f60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic negate for bit-vectors. <br /></td></tr>
<tr class="separator:ad48e47567031b28aa1b58b82e40f60d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc8204049fd3920b75bd255c3c18f74"><td class="memItemLeft" align="right" valign="top"><a id="abdc8204049fd3920b75bd255c3c18f74"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abdc8204049fd3920b75bd255c3c18f74">operator!</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:abdc8204049fd3920b75bd255c3c18f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not for Booleans. <br /></td></tr>
<tr class="separator:abdc8204049fd3920b75bd255c3c18f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="memItemLeft" align="right" valign="top"><a id="a2fb9f43d4ffd7d0cb2061095d1986cbf"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2fb9f43d4ffd7d0cb2061095d1986cbf">operator~</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise complement for bit-vectors. <br /></td></tr>
<tr class="separator:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f36230a9b39200705779d69672701c7"><td class="memItemLeft" align="right" valign="top"><a id="a5f36230a9b39200705779d69672701c7"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a5f36230a9b39200705779d69672701c7">operator&amp;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a5f36230a9b39200705779d69672701c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:a5f36230a9b39200705779d69672701c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="memItemLeft" align="right" valign="top"><a id="a7e4d71727922a8e7cd35bf2f9814c6f8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7e4d71727922a8e7cd35bf2f9814c6f8">operator|</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72e1b0d70d982d3a846436152aef3bc"><td class="memItemLeft" align="right" valign="top"><a id="ad72e1b0d70d982d3a846436152aef3bc"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad72e1b0d70d982d3a846436152aef3bc">operator^</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ad72e1b0d70d982d3a846436152aef3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical XOR (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:ad72e1b0d70d982d3a846436152aef3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28e98c027804fa9307f199552870e86"><td class="memItemLeft" align="right" valign="top"><a id="ae28e98c027804fa9307f199552870e86"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae28e98c027804fa9307f199552870e86">operator&lt;&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ae28e98c027804fa9307f199552870e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift for bit-vectors. <br /></td></tr>
<tr class="separator:ae28e98c027804fa9307f199552870e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1848641ecc2609af5de3888328eddb8"><td class="memItemLeft" align="right" valign="top"><a id="ac1848641ecc2609af5de3888328eddb8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac1848641ecc2609af5de3888328eddb8">operator&gt;&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ac1848641ecc2609af5de3888328eddb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic right shift for bit-vectors. <br /></td></tr>
<tr class="separator:ac1848641ecc2609af5de3888328eddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd757988bbf08aa6ab6395f65de46a"><td class="memItemLeft" align="right" valign="top"><a id="acffd757988bbf08aa6ab6395f65de46a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acffd757988bbf08aa6ab6395f65de46a">Lshr</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:acffd757988bbf08aa6ab6395f65de46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical right shift for bit-vectors. <br /></td></tr>
<tr class="separator:acffd757988bbf08aa6ab6395f65de46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="memItemLeft" align="right" valign="top"><a id="a4a9fbd2386191e9a476af6dbae9ac4d1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4a9fbd2386191e9a476af6dbae9ac4d1">operator+</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned addition for bit-vectors. <br /></td></tr>
<tr class="separator:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28362d954dc9512c7292ef91df694e37"><td class="memItemLeft" align="right" valign="top"><a id="a28362d954dc9512c7292ef91df694e37"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a28362d954dc9512c7292ef91df694e37">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a28362d954dc9512c7292ef91df694e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned subtraction for bit-vectors. <br /></td></tr>
<tr class="separator:a28362d954dc9512c7292ef91df694e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac463e3a89b6404f2537da22ac5b846e1"><td class="memItemLeft" align="right" valign="top"><a id="ac463e3a89b6404f2537da22ac5b846e1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac463e3a89b6404f2537da22ac5b846e1">operator*</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ac463e3a89b6404f2537da22ac5b846e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned multiply for bit-vectors. <br /></td></tr>
<tr class="separator:ac463e3a89b6404f2537da22ac5b846e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab623d5bd7634a20454d574ba4e511fb7"><td class="memItemLeft" align="right" valign="top"><a id="ab623d5bd7634a20454d574ba4e511fb7"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab623d5bd7634a20454d574ba4e511fb7">operator/</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ab623d5bd7634a20454d574ba4e511fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned division for bit-vectors. <br /></td></tr>
<tr class="separator:ab623d5bd7634a20454d574ba4e511fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9e9087364ae3f6a9862167255161d0"><td class="memItemLeft" align="right" valign="top"><a id="aca9e9087364ae3f6a9862167255161d0"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aca9e9087364ae3f6a9862167255161d0">operator&amp;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:aca9e9087364ae3f6a9862167255161d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND with Boolean constant. <br /></td></tr>
<tr class="separator:aca9e9087364ae3f6a9862167255161d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="memItemLeft" align="right" valign="top"><a id="af4ad583ce28ae8f0a7acb3567d00d11a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af4ad583ce28ae8f0a7acb3567d00d11a">operator|</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR with Boolean constant. <br /></td></tr>
<tr class="separator:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4e16eacbe789ffa001734f64c4247"><td class="memItemLeft" align="right" valign="top"><a id="a8bd4e16eacbe789ffa001734f64c4247"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8bd4e16eacbe789ffa001734f64c4247">operator^</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:a8bd4e16eacbe789ffa001734f64c4247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical XOR with Boolean constant. <br /></td></tr>
<tr class="separator:a8bd4e16eacbe789ffa001734f64c4247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="memItemLeft" align="right" valign="top"><a id="a9ce724b1e6f1d4fe10e8b4749df344f1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9ce724b1e6f1d4fe10e8b4749df344f1">operator&lt;&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift with int constant. <br /></td></tr>
<tr class="separator:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1919952d428702d64090f2ea81fa8"><td class="memItemLeft" align="right" valign="top"><a id="a0bb1919952d428702d64090f2ea81fa8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0bb1919952d428702d64090f2ea81fa8">operator&gt;&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a0bb1919952d428702d64090f2ea81fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic right shift with int constant. <br /></td></tr>
<tr class="separator:a0bb1919952d428702d64090f2ea81fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75467ae3bda2dbdcec1e140dada8e41"><td class="memItemLeft" align="right" valign="top"><a id="ad75467ae3bda2dbdcec1e140dada8e41"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad75467ae3bda2dbdcec1e140dada8e41">Lshr</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:ad75467ae3bda2dbdcec1e140dada8e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical right shift with int constant. <br /></td></tr>
<tr class="separator:ad75467ae3bda2dbdcec1e140dada8e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263334136d41928663a22fdb05981dc"><td class="memItemLeft" align="right" valign="top"><a id="a5263334136d41928663a22fdb05981dc"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a5263334136d41928663a22fdb05981dc">operator+</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a5263334136d41928663a22fdb05981dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned addition with constant. <br /></td></tr>
<tr class="separator:a5263334136d41928663a22fdb05981dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabea08abd54989ab2aeb5d549ef34e9"><td class="memItemLeft" align="right" valign="top"><a id="aeabea08abd54989ab2aeb5d549ef34e9"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeabea08abd54989ab2aeb5d549ef34e9">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:aeabea08abd54989ab2aeb5d549ef34e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned subtraction with constant. <br /></td></tr>
<tr class="separator:aeabea08abd54989ab2aeb5d549ef34e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb309682db02df8ccf233b721b6de3a"><td class="memItemLeft" align="right" valign="top"><a id="acdb309682db02df8ccf233b721b6de3a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acdb309682db02df8ccf233b721b6de3a">operator*</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:acdb309682db02df8ccf233b721b6de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned multiply with constant. <br /></td></tr>
<tr class="separator:acdb309682db02df8ccf233b721b6de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658088c73ce3ddee1c514237fa137cb1"><td class="memItemLeft" align="right" valign="top"><a id="a658088c73ce3ddee1c514237fa137cb1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a658088c73ce3ddee1c514237fa137cb1">SRem</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a658088c73ce3ddee1c514237fa137cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic signed remainder. <br /></td></tr>
<tr class="separator:a658088c73ce3ddee1c514237fa137cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae933cd6b19c1340919f27b281ca3101d"><td class="memItemLeft" align="right" valign="top"><a id="ae933cd6b19c1340919f27b281ca3101d"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae933cd6b19c1340919f27b281ca3101d">URem</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ae933cd6b19c1340919f27b281ca3101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic unsigned remainder. <br /></td></tr>
<tr class="separator:ae933cd6b19c1340919f27b281ca3101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd235975dffa30c47d9b10330317422"><td class="memItemLeft" align="right" valign="top"><a id="a6bd235975dffa30c47d9b10330317422"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6bd235975dffa30c47d9b10330317422">SMod</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a6bd235975dffa30c47d9b10330317422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic signed modular. <br /></td></tr>
<tr class="separator:a6bd235975dffa30c47d9b10330317422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40770ca14b70a11f277696dc6c6dff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac40770ca14b70a11f277696dc6c6dff2">SetUnsignedComparison</a> (bool sign)</td></tr>
<tr class="separator:ac40770ca14b70a11f277696dc6c6dff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9b38a78f3d3d10857d632479e1a1f6"><td class="memItemLeft" align="right" valign="top"><a id="acb9b38a78f3d3d10857d632479e1a1f6"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acb9b38a78f3d3d10857d632479e1a1f6">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:acb9b38a78f3d3d10857d632479e1a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal. <br /></td></tr>
<tr class="separator:acb9b38a78f3d3d10857d632479e1a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="memItemLeft" align="right" valign="top"><a id="a43c51f6da7b4a7d2e0bb4e5e06300bfb"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a43c51f6da7b4a7d2e0bb4e5e06300bfb">operator!=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal. <br /></td></tr>
<tr class="separator:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297d9e26e0499970d9ec654667861db"><td class="memItemLeft" align="right" valign="top"><a id="af297d9e26e0499970d9ec654667861db"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af297d9e26e0499970d9ec654667861db">operator&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:af297d9e26e0499970d9ec654667861db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than (bit-vectors only). <br /></td></tr>
<tr class="separator:af297d9e26e0499970d9ec654667861db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130a794f0f175d58089d16bcaabb91ae"><td class="memItemLeft" align="right" valign="top"><a id="a130a794f0f175d58089d16bcaabb91ae"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a130a794f0f175d58089d16bcaabb91ae">operator&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a130a794f0f175d58089d16bcaabb91ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:a130a794f0f175d58089d16bcaabb91ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fd64da42d7b62d90e7723fd9b99155"><td class="memItemLeft" align="right" valign="top"><a id="aa6fd64da42d7b62d90e7723fd9b99155"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa6fd64da42d7b62d90e7723fd9b99155">operator&lt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aa6fd64da42d7b62d90e7723fd9b99155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:aa6fd64da42d7b62d90e7723fd9b99155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3c66d75773fcf81726ef3225bf73be"><td class="memItemLeft" align="right" valign="top"><a id="a7a3c66d75773fcf81726ef3225bf73be"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7a3c66d75773fcf81726ef3225bf73be">operator&gt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a7a3c66d75773fcf81726ef3225bf73be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a7a3c66d75773fcf81726ef3225bf73be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d30cc567f56a578def19edd36f92a"><td class="memItemLeft" align="right" valign="top"><a id="a682d30cc567f56a578def19edd36f92a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a682d30cc567f56a578def19edd36f92a">Ult</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a682d30cc567f56a578def19edd36f92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than (bit-vectors only). <br /></td></tr>
<tr class="separator:a682d30cc567f56a578def19edd36f92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="memItemLeft" align="right" valign="top"><a id="ab2853af9ffe113d87fe08efa8e02b7a3"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab2853af9ffe113d87fe08efa8e02b7a3">Ugt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="memItemLeft" align="right" valign="top"><a id="a4f01ce26f38dd0af7c1b90e26d9d42b9"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4f01ce26f38dd0af7c1b90e26d9d42b9">Ule</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35547378b340cdd037b0c3179a4c333b"><td class="memItemLeft" align="right" valign="top"><a id="a35547378b340cdd037b0c3179a4c333b"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a35547378b340cdd037b0c3179a4c333b">Uge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a35547378b340cdd037b0c3179a4c333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a35547378b340cdd037b0c3179a4c333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c20a840cad15d999b2b05bd04de5d5"><td class="memItemLeft" align="right" valign="top"><a id="a80c20a840cad15d999b2b05bd04de5d5"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a80c20a840cad15d999b2b05bd04de5d5">Slt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a80c20a840cad15d999b2b05bd04de5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than (bit-vectors only). <br /></td></tr>
<tr class="separator:a80c20a840cad15d999b2b05bd04de5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a5c8b2290e4a4592c1c7d89ce117d0"><td class="memItemLeft" align="right" valign="top"><a id="aa0a5c8b2290e4a4592c1c7d89ce117d0"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa0a5c8b2290e4a4592c1c7d89ce117d0">Sgt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aa0a5c8b2290e4a4592c1c7d89ce117d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:aa0a5c8b2290e4a4592c1c7d89ce117d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6220de8b3b7523714a03db7b2127152b"><td class="memItemLeft" align="right" valign="top"><a id="a6220de8b3b7523714a03db7b2127152b"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6220de8b3b7523714a03db7b2127152b">Sle</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a6220de8b3b7523714a03db7b2127152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a6220de8b3b7523714a03db7b2127152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd8ac4aa3c6cc7d655fbd34719db722"><td class="memItemLeft" align="right" valign="top"><a id="a8fd8ac4aa3c6cc7d655fbd34719db722"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8fd8ac4aa3c6cc7d655fbd34719db722">Sge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a8fd8ac4aa3c6cc7d655fbd34719db722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a8fd8ac4aa3c6cc7d655fbd34719db722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad360f16d3ad70c5cc0d85113b9afd004"><td class="memItemLeft" align="right" valign="top"><a id="ad360f16d3ad70c5cc0d85113b9afd004"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad360f16d3ad70c5cc0d85113b9afd004">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:ad360f16d3ad70c5cc0d85113b9afd004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to constant. <br /></td></tr>
<tr class="separator:ad360f16d3ad70c5cc0d85113b9afd004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82358ff9b6a501a461d56adfd66ed18"><td class="memItemLeft" align="right" valign="top"><a id="ab82358ff9b6a501a461d56adfd66ed18"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab82358ff9b6a501a461d56adfd66ed18">operator!=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:ab82358ff9b6a501a461d56adfd66ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to constant. <br /></td></tr>
<tr class="separator:ab82358ff9b6a501a461d56adfd66ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f2f8bf4f027c0029babb8213817638"><td class="memItemLeft" align="right" valign="top"><a id="ab5f2f8bf4f027c0029babb8213817638"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab5f2f8bf4f027c0029babb8213817638">operator&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:ab5f2f8bf4f027c0029babb8213817638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than constant (bit-vectors only). <br /></td></tr>
<tr class="separator:ab5f2f8bf4f027c0029babb8213817638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aebe585f144dcda8d127f484d811b87"><td class="memItemLeft" align="right" valign="top"><a id="a4aebe585f144dcda8d127f484d811b87"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4aebe585f144dcda8d127f484d811b87">operator&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a4aebe585f144dcda8d127f484d811b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a4aebe585f144dcda8d127f484d811b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e571f0425fb78d8c5db5e8ac6068d5"><td class="memItemLeft" align="right" valign="top"><a id="aa0e571f0425fb78d8c5db5e8ac6068d5"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa0e571f0425fb78d8c5db5e8ac6068d5">operator&lt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:aa0e571f0425fb78d8c5db5e8ac6068d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than or equal to constant (bit-vectors only). <br /></td></tr>
<tr class="separator:aa0e571f0425fb78d8c5db5e8ac6068d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff6ce6c3852682a94e08d6c215043e5"><td class="memItemLeft" align="right" valign="top"><a id="a7ff6ce6c3852682a94e08d6c215043e5"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7ff6ce6c3852682a94e08d6c215043e5">operator&gt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a7ff6ce6c3852682a94e08d6c215043e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than or equal to constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a7ff6ce6c3852682a94e08d6c215043e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759610f2918352fcf4e1e7e0dc823dd"><td class="memItemLeft" align="right" valign="top"><a id="a4759610f2918352fcf4e1e7e0dc823dd"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4759610f2918352fcf4e1e7e0dc823dd">Ult</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a4759610f2918352fcf4e1e7e0dc823dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a4759610f2918352fcf4e1e7e0dc823dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1248947928e0da0e300eaddf82cffc7"><td class="memItemLeft" align="right" valign="top"><a id="ae1248947928e0da0e300eaddf82cffc7"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae1248947928e0da0e300eaddf82cffc7">Ugt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:ae1248947928e0da0e300eaddf82cffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than constant (bit-vectors only). <br /></td></tr>
<tr class="separator:ae1248947928e0da0e300eaddf82cffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b51f300e14c91618ebb1f809e05bebf"><td class="memItemLeft" align="right" valign="top"><a id="a6b51f300e14c91618ebb1f809e05bebf"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6b51f300e14c91618ebb1f809e05bebf">Ule</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a6b51f300e14c91618ebb1f809e05bebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than or equal to constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a6b51f300e14c91618ebb1f809e05bebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c6ebe72b1449846b8015fdde196ef7"><td class="memItemLeft" align="right" valign="top"><a id="a08c6ebe72b1449846b8015fdde196ef7"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a08c6ebe72b1449846b8015fdde196ef7">Uge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a08c6ebe72b1449846b8015fdde196ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than or equal to constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a08c6ebe72b1449846b8015fdde196ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1702bbb1749d23e4b1527cfce9b5d0d8"><td class="memItemLeft" align="right" valign="top"><a id="a1702bbb1749d23e4b1527cfce9b5d0d8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1702bbb1749d23e4b1527cfce9b5d0d8">Slt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a1702bbb1749d23e4b1527cfce9b5d0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a1702bbb1749d23e4b1527cfce9b5d0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695d878ff8a790635f99dc809071f03c"><td class="memItemLeft" align="right" valign="top"><a id="a695d878ff8a790635f99dc809071f03c"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a695d878ff8a790635f99dc809071f03c">Sgt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a695d878ff8a790635f99dc809071f03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a695d878ff8a790635f99dc809071f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621541257a785f4583bb027f83c3f42f"><td class="memItemLeft" align="right" valign="top"><a id="a621541257a785f4583bb027f83c3f42f"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a621541257a785f4583bb027f83c3f42f">Sle</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a621541257a785f4583bb027f83c3f42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than or equal to constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a621541257a785f4583bb027f83c3f42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc7736b91b11e30ffabf8f473d310fb"><td class="memItemLeft" align="right" valign="top"><a id="a7bc7736b91b11e30ffabf8f473d310fb"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7bc7736b91b11e30ffabf8f473d310fb">Sge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;b)</td></tr>
<tr class="memdesc:a7bc7736b91b11e30ffabf8f473d310fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than or equal to constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a7bc7736b91b11e30ffabf8f473d310fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4006e3000db73b20ee6f06a713d1bd"><td class="memItemLeft" align="right" valign="top"><a id="a1f4006e3000db73b20ee6f06a713d1bd"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1f4006e3000db73b20ee6f06a713d1bd">Load</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;addr)</td></tr>
<tr class="memdesc:a1f4006e3000db73b20ee6f06a713d1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from memory. <br /></td></tr>
<tr class="separator:a1f4006e3000db73b20ee6f06a713d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32b36b718a94a19184be0eaa66e5774"><td class="memItemLeft" align="right" valign="top"><a id="ad32b36b718a94a19184be0eaa66e5774"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad32b36b718a94a19184be0eaa66e5774">Store</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;addr, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;data)</td></tr>
<tr class="memdesc:ad32b36b718a94a19184be0eaa66e5774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store to memory. <br /></td></tr>
<tr class="separator:ad32b36b718a94a19184be0eaa66e5774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60c2c9d8f187da5fa6a0f516a0381fc"><td class="memItemLeft" align="right" valign="top"><a id="ab60c2c9d8f187da5fa6a0f516a0381fc"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab60c2c9d8f187da5fa6a0f516a0381fc">Load</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;addr)</td></tr>
<tr class="memdesc:ab60c2c9d8f187da5fa6a0f516a0381fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from memory with constant address. <br /></td></tr>
<tr class="separator:ab60c2c9d8f187da5fa6a0f516a0381fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30734f63759c0ae330fc4a9ed6a18423"><td class="memItemLeft" align="right" valign="top"><a id="a30734f63759c0ae330fc4a9ed6a18423"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a30734f63759c0ae330fc4a9ed6a18423">Store</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;addr, const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;data)</td></tr>
<tr class="memdesc:a30734f63759c0ae330fc4a9ed6a18423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store to memory at constant address and data. <br /></td></tr>
<tr class="separator:a30734f63759c0ae330fc4a9ed6a18423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b423140c9b8a60e1bac56e90ba175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa74b423140c9b8a60e1bac56e90ba175">Concat</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;msbv, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;lsbv)</td></tr>
<tr class="memdesc:aa74b423140c9b8a60e1bac56e90ba175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two bit-vectors.  <a href="namespaceilang.html#aa74b423140c9b8a60e1bac56e90ba175">More...</a><br /></td></tr>
<tr class="separator:aa74b423140c9b8a60e1bac56e90ba175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73a95aa5988d50567c5ff6fe53de913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab73a95aa5988d50567c5ff6fe53de913">Extract</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;hi, const int &amp;lo)</td></tr>
<tr class="memdesc:ab73a95aa5988d50567c5ff6fe53de913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract bit-field in the bit-vector.  <a href="namespaceilang.html#ab73a95aa5988d50567c5ff6fe53de913">More...</a><br /></td></tr>
<tr class="separator:ab73a95aa5988d50567c5ff6fe53de913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a28a510ed3c6bbe8cb314bdfb8d664283">SelectBit</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;idx)</td></tr>
<tr class="memdesc:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract single bit in the bit-vector.  <a href="namespaceilang.html#a28a510ed3c6bbe8cb314bdfb8d664283">More...</a><br /></td></tr>
<tr class="separator:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad992886a38803601f88f987b174f4c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad992886a38803601f88f987b174f4c34">ZExt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;length)</td></tr>
<tr class="memdesc:ad992886a38803601f88f987b174f4c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extend the bit-vector to the specified length.  <a href="namespaceilang.html#ad992886a38803601f88f987b174f4c34">More...</a><br /></td></tr>
<tr class="separator:ad992886a38803601f88f987b174f4c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a2da11f53d77bc38c204c87f6eecda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae0a2da11f53d77bc38c204c87f6eecda">SExt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;length)</td></tr>
<tr class="memdesc:ae0a2da11f53d77bc38c204c87f6eecda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the bit-vector to the specified length.  <a href="namespaceilang.html#ae0a2da11f53d77bc38c204c87f6eecda">More...</a><br /></td></tr>
<tr class="separator:ae0a2da11f53d77bc38c204c87f6eecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a459a835293a24f66c8e2fcf35aa50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a35a459a835293a24f66c8e2fcf35aa50">LRotate</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;immediate)</td></tr>
<tr class="memdesc:a35a459a835293a24f66c8e2fcf35aa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-rotate the bit-vector with immediate number of times.  <a href="namespaceilang.html#a35a459a835293a24f66c8e2fcf35aa50">More...</a><br /></td></tr>
<tr class="separator:a35a459a835293a24f66c8e2fcf35aa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd95e8beb244056395bb6f24dca2173b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abd95e8beb244056395bb6f24dca2173b">RRotate</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;immediate)</td></tr>
<tr class="memdesc:abd95e8beb244056395bb6f24dca2173b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-rotate the bit-vector with immediate number of times.  <a href="namespaceilang.html#abd95e8beb244056395bb6f24dca2173b">More...</a><br /></td></tr>
<tr class="separator:abd95e8beb244056395bb6f24dca2173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717385221eb8322e7b19096ba48d2516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a717385221eb8322e7b19096ba48d2516">Imply</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;ante, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;cons)</td></tr>
<tr class="memdesc:a717385221eb8322e7b19096ba48d2516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical imply for Booleans.  <a href="namespaceilang.html#a717385221eb8322e7b19096ba48d2516">More...</a><br /></td></tr>
<tr class="separator:a717385221eb8322e7b19096ba48d2516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63ed74adc72075df524ec933146f0f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab63ed74adc72075df524ec933146f0f3">Ite</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;cond, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;t, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;f)</td></tr>
<tr class="memdesc:ab63ed74adc72075df524ec933146f0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If-then-else on the Boolean condition.  <a href="namespaceilang.html#ab63ed74adc72075df524ec933146f0f3">More...</a><br /></td></tr>
<tr class="separator:ab63ed74adc72075df524ec933146f0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a41b370cb62e6bb2a4abba9b9f482ff6f">BoolConst</a> (bool bool_val)</td></tr>
<tr class="memdesc:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Boolean constant.  <a href="namespaceilang.html#a41b370cb62e6bb2a4abba9b9f482ff6f">More...</a><br /></td></tr>
<tr class="separator:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdb47cd005c9a3512c5aa2047fcb27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a5fdb47cd005c9a3512c5aa2047fcb27c">BvConst</a> (const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;bv_val, const int &amp;bit_width)</td></tr>
<tr class="memdesc:a5fdb47cd005c9a3512c5aa2047fcb27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bit-vector constant.  <a href="namespaceilang.html#a5fdb47cd005c9a3512c5aa2047fcb27c">More...</a><br /></td></tr>
<tr class="separator:a5fdb47cd005c9a3512c5aa2047fcb27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e7f6d6efdece168ce82d3fa3042d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac1e7f6d6efdece168ce82d3fa3042d9b">MemConst</a> (const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;def_val, const std::map&lt; <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a>, <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &gt; &amp;vals, const int &amp;addr_width, const int &amp;data_width)</td></tr>
<tr class="memdesc:ac1e7f6d6efdece168ce82d3fa3042d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a memory constant.  <a href="namespaceilang.html#ac1e7f6d6efdece168ce82d3fa3042d9b">More...</a><br /></td></tr>
<tr class="separator:ac1e7f6d6efdece168ce82d3fa3042d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc42fabe7c53eadf8db66da979cd156"><td class="memItemLeft" align="right" valign="top"><a id="aafc42fabe7c53eadf8db66da979cd156"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aafc42fabe7c53eadf8db66da979cd156">TopEqual</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aafc42fabe7c53eadf8db66da979cd156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically equivalent. <br /></td></tr>
<tr class="separator:aafc42fabe7c53eadf8db66da979cd156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="memItemLeft" align="right" valign="top"><a id="ab9bcc3ec35bb95561155203ab61e2e0d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab9bcc3ec35bb95561155203ab61e2e0d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;expr)</td></tr>
<tr class="memdesc:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the <a class="el" href="classilang_1_1_expr_ref.html" title="The wrapper of Expr (e.g. state var, var relation, constant, etc).">ExprRef</a>. <br /></td></tr>
<tr class="separator:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7e5decaea56c186a7576ddf30379b"><td class="memItemLeft" align="right" valign="top"><a id="a36a7e5decaea56c186a7576ddf30379b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a36a7e5decaea56c186a7576ddf30379b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_instr_ref.html">InstrRef</a> &amp;instr)</td></tr>
<tr class="memdesc:a36a7e5decaea56c186a7576ddf30379b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the Instruction. <br /></td></tr>
<tr class="separator:a36a7e5decaea56c186a7576ddf30379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="memItemLeft" align="right" valign="top"><a id="a6a1bf9ab1a26dcdd7ac71b99181c96ac"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6a1bf9ab1a26dcdd7ac71b99181c96ac">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;ila)</td></tr>
<tr class="memdesc:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the ILA. <br /></td></tr>
<tr class="separator:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b4e6aeabd9ca97928e0aab10648587"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a21b4e6aeabd9ca97928e0aab10648587">ExportIlaPortable</a> (const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;ila, const std::string &amp;file_name)</td></tr>
<tr class="memdesc:a21b4e6aeabd9ca97928e0aab10648587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the ILA portable to file.  <a href="namespaceilang.html#a21b4e6aeabd9ca97928e0aab10648587">More...</a><br /></td></tr>
<tr class="separator:a21b4e6aeabd9ca97928e0aab10648587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cdb6e544ecc6bec6b75edcf51ef694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_ila.html">Ila</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a58cdb6e544ecc6bec6b75edcf51ef694">ImportIlaPortable</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:a58cdb6e544ecc6bec6b75edcf51ef694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import the ILA portable from file.  <a href="namespaceilang.html#a58cdb6e544ecc6bec6b75edcf51ef694">More...</a><br /></td></tr>
<tr class="separator:a58cdb6e544ecc6bec6b75edcf51ef694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bfc39bc1e23556a38f0bea47a2c6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_ila.html">Ila</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a74bfc39bc1e23556a38f0bea47a2c6dc">ImportSynthAbstraction</a> (const std::string &amp;file_name, const std::string &amp;ila_name)</td></tr>
<tr class="memdesc:a74bfc39bc1e23556a38f0bea47a2c6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import the synthesized abstraction from file.  <a href="namespaceilang.html#a74bfc39bc1e23556a38f0bea47a2c6dc">More...</a><br /></td></tr>
<tr class="separator:a74bfc39bc1e23556a38f0bea47a2c6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e232d6d5294946f552703a2eca544b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a29e232d6d5294946f552703a2eca544b">ImportChildSynthAbstraction</a> (const std::string &amp;file_name, <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;parent, const std::string &amp;ila_name)</td></tr>
<tr class="memdesc:a29e232d6d5294946f552703a2eca544b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import the synthesized (child-)abstraction from file, under the given parent ILA.  <a href="namespaceilang.html#a29e232d6d5294946f552703a2eca544b">More...</a><br /></td></tr>
<tr class="separator:a29e232d6d5294946f552703a2eca544b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1ef1665cc30522240ca2ea43e75a65"><td class="memItemLeft" align="right" valign="top"><a id="a7c1ef1665cc30522240ca2ea43e75a65"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7c1ef1665cc30522240ca2ea43e75a65">getIteUnknownCondVal</a> (const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;e, <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;c, <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a> &amp;v)</td></tr>
<tr class="memdesc:a7c1ef1665cc30522240ca2ea43e75a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to deal with Ite(c, v, apply(<b>unknown</b>) );. <br /></td></tr>
<tr class="separator:a7c1ef1665cc30522240ca2ea43e75a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181bcd7690eed0466a301469995543a4"><td class="memItemLeft" align="right" valign="top"><a id="a181bcd7690eed0466a301469995543a4"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a181bcd7690eed0466a301469995543a4">Z3And</a> (const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a181bcd7690eed0466a301469995543a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is just a shortcut to be used for generated axiom. <br /></td></tr>
<tr class="separator:a181bcd7690eed0466a301469995543a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6810cc71b8a884538774f9f0cae4a48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad6810cc71b8a884538774f9f0cae4a48">ImportSynthAbsFromFile</a> (const std::string &amp;file_name, const std::string &amp;ila_name=&quot;&quot;)</td></tr>
<tr class="memdesc:ad6810cc71b8a884538774f9f0cae4a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from file the abstraction from the synthesis engine and convert it into an ILA model.  <a href="namespaceilang.html#ad6810cc71b8a884538774f9f0cae4a48">More...</a><br /></td></tr>
<tr class="separator:ad6810cc71b8a884538774f9f0cae4a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1380087070c036209a6000d2034586b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa1380087070c036209a6000d2034586b">ImportSynthAbsFromFileHier</a> (const std::string &amp;file_name, const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> parent, const std::string &amp;ila_name=&quot;&quot;)</td></tr>
<tr class="memdesc:aa1380087070c036209a6000d2034586b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from file the abstraction from the synthesis engine and convert it into a child-ILA of the specified parent ILA.  <a href="namespaceilang.html#aa1380087070c036209a6000d2034586b">More...</a><br /></td></tr>
<tr class="separator:aa1380087070c036209a6000d2034586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca5c66b61666678437e9145181ec121"><td class="memItemLeft" align="right" valign="top"><a id="aeca5c66b61666678437e9145181ec121"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeca5c66b61666678437e9145181ec121">os_portable_mkdir</a> (const std::string &amp;dir)</td></tr>
<tr class="memdesc:aeca5c66b61666678437e9145181ec121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dir, true -&gt; suceeded , ow false. <br /></td></tr>
<tr class="separator:aeca5c66b61666678437e9145181ec121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd59e78d3468c65ac2ca90374046fbd"><td class="memItemLeft" align="right" valign="top"><a id="aefd59e78d3468c65ac2ca90374046fbd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aefd59e78d3468c65ac2ca90374046fbd">os_portable_copy_dir</a> (const std::string &amp;src, const std::string &amp;dst)</td></tr>
<tr class="memdesc:aefd59e78d3468c65ac2ca90374046fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all file from a source dir to the destination dir. <br /></td></tr>
<tr class="separator:aefd59e78d3468c65ac2ca90374046fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9d76f39d3c86e48d40510503f8fa7b"><td class="memItemLeft" align="right" valign="top"><a id="a1e9d76f39d3c86e48d40510503f8fa7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1e9d76f39d3c86e48d40510503f8fa7b">os_portable_copy_file_to_dir</a> (const std::string &amp;src, const std::string &amp;dst)</td></tr>
<tr class="memdesc:a1e9d76f39d3c86e48d40510503f8fa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one file to the destination dir. <br /></td></tr>
<tr class="separator:a1e9d76f39d3c86e48d40510503f8fa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1adaa03ee7643f536c411bbd19dcbe"><td class="memItemLeft" align="right" valign="top"><a id="aed1adaa03ee7643f536c411bbd19dcbe"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aed1adaa03ee7643f536c411bbd19dcbe">os_portable_append_dir</a> (const std::string &amp;dir1, const std::string &amp;dir2)</td></tr>
<tr class="memdesc:aed1adaa03ee7643f536c411bbd19dcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append two paths. <br /></td></tr>
<tr class="separator:aed1adaa03ee7643f536c411bbd19dcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3643adfcdd9690b38d1805b6c6bffa98"><td class="memItemLeft" align="right" valign="top"><a id="a3643adfcdd9690b38d1805b6c6bffa98"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a3643adfcdd9690b38d1805b6c6bffa98">os_portable_append_dir</a> (const std::string &amp;dir1, const std::vector&lt; std::string &gt; &amp;dirs)</td></tr>
<tr class="memdesc:a3643adfcdd9690b38d1805b6c6bffa98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append paths to another. <br /></td></tr>
<tr class="separator:a3643adfcdd9690b38d1805b6c6bffa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85352bb17b3608b7e37a9b68ca2e4974"><td class="memItemLeft" align="right" valign="top"><a id="a85352bb17b3608b7e37a9b68ca2e4974"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a85352bb17b3608b7e37a9b68ca2e4974">os_portable_join_dir</a> (const std::vector&lt; std::string &gt; &amp;dirs)</td></tr>
<tr class="memdesc:a85352bb17b3608b7e37a9b68ca2e4974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join paths. <br /></td></tr>
<tr class="separator:a85352bb17b3608b7e37a9b68ca2e4974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a8afad76084f511530410083363994"><td class="memItemLeft" align="right" valign="top"><a id="a39a8afad76084f511530410083363994"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a39a8afad76084f511530410083363994">os_portable_remove_file_name_extension</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a39a8afad76084f511530410083363994"><td class="mdescLeft">&#160;</td><td class="mdescRight">C:\a.txt -&gt; C:\a or /a/b/c.txt -&gt; a/b/c. <br /></td></tr>
<tr class="separator:a39a8afad76084f511530410083363994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d86bebcf221a241039af4bd2f5ee4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structilang_1_1execute__result.html">execute_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a09d86bebcf221a241039af4bd2f5ee4a">os_portable_execute_shell</a> (const std::vector&lt; std::string &gt; &amp;cmdargs, const std::string &amp;redirect_output_file=&quot;&quot;, <a class="el" href="namespaceilang.html#a6b3372e18c965cab7e146d01c376a24a">redirect_t</a> rdt=redirect_t::BOTH, unsigned timeout=0, const std::string &amp;pid_file_name=&quot;&quot;)</td></tr>
<tr class="separator:a09d86bebcf221a241039af4bd2f5ee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f4521ec82c6af4695e31e917082828"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a79f4521ec82c6af4695e31e917082828">os_portable_file_name_from_path</a> (const std::string &amp;path)</td></tr>
<tr class="separator:a79f4521ec82c6af4695e31e917082828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f987f62bad43e9a6876076441c66b6f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7f987f62bad43e9a6876076441c66b6f">os_portable_path_from_path</a> (const std::string &amp;path)</td></tr>
<tr class="separator:a7f987f62bad43e9a6876076441c66b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceede0cf3509c4185b58b9a158a9bb9"><td class="memItemLeft" align="right" valign="top"><a id="a1ceede0cf3509c4185b58b9a158a9bb9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1ceede0cf3509c4185b58b9a158a9bb9">os_portable_read_last_line</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a1ceede0cf3509c4185b58b9a158a9bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the last meaningful line from a file <br /></td></tr>
<tr class="separator:a1ceede0cf3509c4185b58b9a158a9bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82e0b65debabf8d074dd2a54ed38793"><td class="memItemLeft" align="right" valign="top"><a id="ab82e0b65debabf8d074dd2a54ed38793"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab82e0b65debabf8d074dd2a54ed38793">os_portable_chdir</a> (const std::string &amp;dirname)</td></tr>
<tr class="memdesc:ab82e0b65debabf8d074dd2a54ed38793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change current directory: true if success. <br /></td></tr>
<tr class="separator:ab82e0b65debabf8d074dd2a54ed38793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76d6610763b865acbab68d621ef1326"><td class="memItemLeft" align="right" valign="top"><a id="ad76d6610763b865acbab68d621ef1326"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad76d6610763b865acbab68d621ef1326">os_portable_getcwd</a> ()</td></tr>
<tr class="memdesc:ad76d6610763b865acbab68d621ef1326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current directory. <br /></td></tr>
<tr class="separator:ad76d6610763b865acbab68d621ef1326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5002dc8078f121ff03b282d1637b4c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad5002dc8078f121ff03b282d1637b4c0">SetLogLevel</a> (const int &amp;lvl)</td></tr>
<tr class="memdesc:ad5002dc8078f121ff03b282d1637b4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimun log level. Log messages at or above this level will be logged. (Default: 0)  <a href="namespaceilang.html#ad5002dc8078f121ff03b282d1637b4c0">More...</a><br /></td></tr>
<tr class="separator:ad5002dc8078f121ff03b282d1637b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad694e631ce9de3140f3d3991f87728"><td class="memItemLeft" align="right" valign="top"><a id="a4ad694e631ce9de3140f3d3991f87728"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4ad694e631ce9de3140f3d3991f87728">SetLogPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a4ad694e631ce9de3140f3d3991f87728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path for log file. If specified, logfiles are written into this directory instead of the default logging directory (/tmp). <br /></td></tr>
<tr class="separator:a4ad694e631ce9de3140f3d3991f87728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297a8bf42d97a385aa18916321c6bce6"><td class="memItemLeft" align="right" valign="top"><a id="a297a8bf42d97a385aa18916321c6bce6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a297a8bf42d97a385aa18916321c6bce6">SetToStdErr</a> (const int &amp;to_err)</td></tr>
<tr class="memdesc:a297a8bf42d97a385aa18916321c6bce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe log to stderr. Log messages to stderr instead of logfiles, if set to 1. <br /></td></tr>
<tr class="separator:a297a8bf42d97a385aa18916321c6bce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffb6d5aba9957312e650446e85f9221"><td class="memItemLeft" align="right" valign="top"><a id="acffb6d5aba9957312e650446e85f9221"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acffb6d5aba9957312e650446e85f9221">IntToStrCustomBase</a> (uint64_t value, unsigned base, bool uppercase)</td></tr>
<tr class="memdesc:acffb6d5aba9957312e650446e85f9221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform int to string with different bases. <br /></td></tr>
<tr class="separator:acffb6d5aba9957312e650446e85f9221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0991fc567e0acf208e32077bfa58c0e8"><td class="memItemLeft" align="right" valign="top"><a id="a0991fc567e0acf208e32077bfa58c0e8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0991fc567e0acf208e32077bfa58c0e8">StrToUpper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a0991fc567e0acf208e32077bfa58c0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basic string to upper case. <br /></td></tr>
<tr class="separator:a0991fc567e0acf208e32077bfa58c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cdb1960acea845bdad15ad077fb1e7"><td class="memItemLeft" align="right" valign="top"><a id="a44cdb1960acea845bdad15ad077fb1e7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a44cdb1960acea845bdad15ad077fb1e7">StrToLower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a44cdb1960acea845bdad15ad077fb1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basic string to lower case. <br /></td></tr>
<tr class="separator:a44cdb1960acea845bdad15ad077fb1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf3586b9c4507e7a8ba88bb181b158"><td class="memItemLeft" align="right" valign="top"><a id="a10cf3586b9c4507e7a8ba88bb181b158"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a10cf3586b9c4507e7a8ba88bb181b158">StrToBool</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a10cf3586b9c4507e7a8ba88bb181b158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string is "true" or "True". <br /></td></tr>
<tr class="separator:a10cf3586b9c4507e7a8ba88bb181b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc40506a335870a67d4ff33bbf9f778"><td class="memItemLeft" align="right" valign="top"><a id="a1dc40506a335870a67d4ff33bbf9f778"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1dc40506a335870a67d4ff33bbf9f778">StrToInt</a> (const std::string &amp;str, int base=10)</td></tr>
<tr class="memdesc:a1dc40506a335870a67d4ff33bbf9f778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value represented in the string, e.g. "10". <br /></td></tr>
<tr class="separator:a1dc40506a335870a67d4ff33bbf9f778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef0968054e5bf9cf7feaa9b41bc88fc"><td class="memItemLeft" align="right" valign="top"><a id="acef0968054e5bf9cf7feaa9b41bc88fc"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acef0968054e5bf9cf7feaa9b41bc88fc">StrToLong</a> (const std::string &amp;str, int base=10)</td></tr>
<tr class="memdesc:acef0968054e5bf9cf7feaa9b41bc88fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value represented in the string in long type, e.g. "10". <br /></td></tr>
<tr class="separator:acef0968054e5bf9cf7feaa9b41bc88fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1fad05aa2476bbc4a0b771add265f2"><td class="memItemLeft" align="right" valign="top"><a id="a2d1fad05aa2476bbc4a0b771add265f2"></a>
unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2d1fad05aa2476bbc4a0b771add265f2">StrToULongLong</a> (const std::string &amp;str, int base=10)</td></tr>
<tr class="memdesc:a2d1fad05aa2476bbc4a0b771add265f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value represented in the string in unsigned long long, e.g. "10". <br /></td></tr>
<tr class="separator:a2d1fad05aa2476bbc4a0b771add265f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e626210f69fa8d6c5a98c73ed3db67d"><td class="memItemLeft" align="right" valign="top"><a id="a5e626210f69fa8d6c5a98c73ed3db67d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a5e626210f69fa8d6c5a98c73ed3db67d">StrLeftTrim</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:a5e626210f69fa8d6c5a98c73ed3db67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a string from start (in place) <br /></td></tr>
<tr class="separator:a5e626210f69fa8d6c5a98c73ed3db67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78fd0ec4241dfe0182ac9b2549a5aca"><td class="memItemLeft" align="right" valign="top"><a id="af78fd0ec4241dfe0182ac9b2549a5aca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af78fd0ec4241dfe0182ac9b2549a5aca">StrRightTrim</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:af78fd0ec4241dfe0182ac9b2549a5aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a string from end (in place) <br /></td></tr>
<tr class="separator:af78fd0ec4241dfe0182ac9b2549a5aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61aac872daaed68756d6b75b376815d"><td class="memItemLeft" align="right" valign="top"><a id="aa61aac872daaed68756d6b75b376815d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa61aac872daaed68756d6b75b376815d">StrTrim</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:aa61aac872daaed68756d6b75b376815d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a string from both ends (in place) <br /></td></tr>
<tr class="separator:aa61aac872daaed68756d6b75b376815d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0044ba6e7d230be9715ebee1ec77dcae"><td class="memItemLeft" align="right" valign="top"><a id="a0044ba6e7d230be9715ebee1ec77dcae"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0044ba6e7d230be9715ebee1ec77dcae">Split</a> (const std::string &amp;str, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a0044ba6e7d230be9715ebee1ec77dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-style split , return a vector of splitted strings. <br /></td></tr>
<tr class="separator:a0044ba6e7d230be9715ebee1ec77dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c4d3feea37017130bce31eb66db90"><td class="memItemLeft" align="right" valign="top"><a id="a668c4d3feea37017130bce31eb66db90"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a668c4d3feea37017130bce31eb66db90">SplitSpaceTabEnter</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a668c4d3feea37017130bce31eb66db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-style split behavior, delim: space tab enter and their combiniations. <br /></td></tr>
<tr class="separator:a668c4d3feea37017130bce31eb66db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7f41f64940afe64a721f33752b619c"><td class="memItemLeft" align="right" valign="top"><a id="aeb7f41f64940afe64a721f33752b619c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeb7f41f64940afe64a721f33752b619c">Join</a> (const std::vector&lt; std::string &gt; &amp;in, const std::string &amp;delim)</td></tr>
<tr class="memdesc:aeb7f41f64940afe64a721f33752b619c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-style join, return a string that joins the list by the delim. <br /></td></tr>
<tr class="separator:aeb7f41f64940afe64a721f33752b619c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd38a759754f99ecc5103408cb5bee7"><td class="memItemLeft" align="right" valign="top"><a id="a3cd38a759754f99ecc5103408cb5bee7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a3cd38a759754f99ecc5103408cb5bee7">RemoveWhiteSpace</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a3cd38a759754f99ecc5103408cb5bee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove whitespace " \n\t\r\f\v" from the input string. <br /></td></tr>
<tr class="separator:a3cd38a759754f99ecc5103408cb5bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edef00da62caf959c84b6cff88b035d"><td class="memItemLeft" align="right" valign="top"><a id="a7edef00da62caf959c84b6cff88b035d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7edef00da62caf959c84b6cff88b035d">ReplaceAll</a> (const std::string &amp;str, const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a7edef00da62caf959c84b6cff88b035d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrance of substring a by substring b. <br /></td></tr>
<tr class="separator:a7edef00da62caf959c84b6cff88b035d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1f77ed0ab47a14e63fde64bbdad506"><td class="memItemLeft" align="right" valign="top"><a id="a8d1f77ed0ab47a14e63fde64bbdad506"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8d1f77ed0ab47a14e63fde64bbdad506">ReFindList</a> (const std::string &amp;s, const std::string &amp;re)</td></tr>
<tr class="memdesc:a8d1f77ed0ab47a14e63fde64bbdad506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out a list of substring by the regular expression. <br /></td></tr>
<tr class="separator:a8d1f77ed0ab47a14e63fde64bbdad506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f5d61665a892dad75f4db1fbcc5ef0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a53f5d61665a892dad75f4db1fbcc5ef0">ReFindAndDo</a> (const std::string &amp;s, const std::string &amp;re, std::function&lt; std::string(std::string)&gt; f)</td></tr>
<tr class="separator:a53f5d61665a892dad75f4db1fbcc5ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc31e7540cbe817478e2833f4766d07"><td class="memItemLeft" align="right" valign="top"><a id="aefc31e7540cbe817478e2833f4766d07"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRExprUsable</b> ()</td></tr>
<tr class="separator:aefc31e7540cbe817478e2833f4766d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e190c27119808c48ac1704b59a6bed"><td class="memItemLeft" align="right" valign="top"><a id="ae7e190c27119808c48ac1704b59a6bed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae7e190c27119808c48ac1704b59a6bed">StrEndsWith</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:ae7e190c27119808c48ac1704b59a6bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if str ends with suffix. <br /></td></tr>
<tr class="separator:ae7e190c27119808c48ac1704b59a6bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76da30bac72fc40c479b997bb1d20b03"><td class="memItemLeft" align="right" valign="top"><a id="a76da30bac72fc40c479b997bb1d20b03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a76da30bac72fc40c479b997bb1d20b03">StrStartsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a76da30bac72fc40c479b997bb1d20b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if str starts with prefix. <br /></td></tr>
<tr class="separator:a76da30bac72fc40c479b997bb1d20b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2411ceb3640ae22d12b6bfa6966c5ec8"><td class="memItemLeft" align="right" valign="top"><a id="a2411ceb3640ae22d12b6bfa6966c5ec8"></a>
<a class="el" href="namespaceilang.html#af9b38d4e87534db4ff8b793d11d1d950">BvValType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2411ceb3640ae22d12b6bfa6966c5ec8">Z3BvVal</a> (const <a class="el" href="namespaceilang.html#af9b38d4e87534db4ff8b793d11d1d950">BvValType</a> &amp;bv_val)</td></tr>
<tr class="memdesc:a2411ceb3640ae22d12b6bfa6966c5ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 bit-vector constant numeric. <br /></td></tr>
<tr class="separator:a2411ceb3640ae22d12b6bfa6966c5ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebfc3854c74ab3f2d1bd4e44305692f"><td class="memItemLeft" align="right" valign="top"><a id="adebfc3854c74ab3f2d1bd4e44305692f"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adebfc3854c74ab3f2d1bd4e44305692f">Z3Implies</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:adebfc3854c74ab3f2d1bd4e44305692f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 implies ast node construction. <br /></td></tr>
<tr class="separator:adebfc3854c74ab3f2d1bd4e44305692f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c925e40db7a9745e41f1bbceabc9fd"><td class="memItemLeft" align="right" valign="top"><a id="a27c925e40db7a9745e41f1bbceabc9fd"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a27c925e40db7a9745e41f1bbceabc9fd">Z3Shl</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a27c925e40db7a9745e41f1bbceabc9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 shl ast node construction. <br /></td></tr>
<tr class="separator:a27c925e40db7a9745e41f1bbceabc9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfa4e4993b16400643d2d217342116a"><td class="memItemLeft" align="right" valign="top"><a id="aebfa4e4993b16400643d2d217342116a"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aebfa4e4993b16400643d2d217342116a">Z3Ashr</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:aebfa4e4993b16400643d2d217342116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 ashr ast node construction. <br /></td></tr>
<tr class="separator:aebfa4e4993b16400643d2d217342116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3aaf13ea691b9badc083bc800d8786"><td class="memItemLeft" align="right" valign="top"><a id="a7d3aaf13ea691b9badc083bc800d8786"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7d3aaf13ea691b9badc083bc800d8786">Z3Lshr</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a7d3aaf13ea691b9badc083bc800d8786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 lshr ast node construction. <br /></td></tr>
<tr class="separator:a7d3aaf13ea691b9badc083bc800d8786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d00889eec3e4c792ad77b3e6ea2f6e"><td class="memItemLeft" align="right" valign="top"><a id="a17d00889eec3e4c792ad77b3e6ea2f6e"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a17d00889eec3e4c792ad77b3e6ea2f6e">Z3SRem</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a17d00889eec3e4c792ad77b3e6ea2f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 shl ast node construction. <br /></td></tr>
<tr class="separator:a17d00889eec3e4c792ad77b3e6ea2f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cff55f8c79381cdc1e89060d6d0560a"><td class="memItemLeft" align="right" valign="top"><a id="a7cff55f8c79381cdc1e89060d6d0560a"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7cff55f8c79381cdc1e89060d6d0560a">Z3URem</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a7cff55f8c79381cdc1e89060d6d0560a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 shl ast node construction. <br /></td></tr>
<tr class="separator:a7cff55f8c79381cdc1e89060d6d0560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b77c63f95149d13ccb52cee519ed732"><td class="memItemLeft" align="right" valign="top"><a id="a4b77c63f95149d13ccb52cee519ed732"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4b77c63f95149d13ccb52cee519ed732">Z3SMod</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a4b77c63f95149d13ccb52cee519ed732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 shl ast node construction. <br /></td></tr>
<tr class="separator:a4b77c63f95149d13ccb52cee519ed732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd62d7446c3eacdba8fb30edbc0e7fae"><td class="memItemLeft" align="right" valign="top"><a id="abd62d7446c3eacdba8fb30edbc0e7fae"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abd62d7446c3eacdba8fb30edbc0e7fae">Z3ZExt</a> (z3::context &amp;ctx, const z3::expr &amp;e, const unsigned &amp;w)</td></tr>
<tr class="memdesc:abd62d7446c3eacdba8fb30edbc0e7fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 zext ast node construction. <br /></td></tr>
<tr class="separator:abd62d7446c3eacdba8fb30edbc0e7fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e7a7410240e86668b47d5201edc102"><td class="memItemLeft" align="right" valign="top"><a id="a57e7a7410240e86668b47d5201edc102"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a57e7a7410240e86668b47d5201edc102">Z3SExt</a> (z3::context &amp;ctx, const z3::expr &amp;e, const unsigned &amp;w)</td></tr>
<tr class="memdesc:a57e7a7410240e86668b47d5201edc102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 sext ast node construction. <br /></td></tr>
<tr class="separator:a57e7a7410240e86668b47d5201edc102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1861a9ce80f5fa4dd8e8303d6f9b83"><td class="memItemLeft" align="right" valign="top"><a id="a6c1861a9ce80f5fa4dd8e8303d6f9b83"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6c1861a9ce80f5fa4dd8e8303d6f9b83">Z3LRotate</a> (z3::context &amp;ctx, z3::expr &amp;e, unsigned &amp;w)</td></tr>
<tr class="memdesc:a6c1861a9ce80f5fa4dd8e8303d6f9b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 left rotate ast node construction. <br /></td></tr>
<tr class="separator:a6c1861a9ce80f5fa4dd8e8303d6f9b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7098de02c4e753e72e7d7d9fcef72b"><td class="memItemLeft" align="right" valign="top"><a id="a5b7098de02c4e753e72e7d7d9fcef72b"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a5b7098de02c4e753e72e7d7d9fcef72b">Z3RRotate</a> (z3::context &amp;ctx, z3::expr &amp;e, unsigned &amp;w)</td></tr>
<tr class="memdesc:a5b7098de02c4e753e72e7d7d9fcef72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 right rotate ast node construction. <br /></td></tr>
<tr class="separator:a5b7098de02c4e753e72e7d7d9fcef72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ebb4cd13cdea9917d3e2b7cc3bfbbb"><td class="memItemLeft" align="right" valign="top"><a id="a78ebb4cd13cdea9917d3e2b7cc3bfbbb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a78ebb4cd13cdea9917d3e2b7cc3bfbbb">Z3Expr2String</a> (z3::context &amp;ctx, const z3::expr &amp;e)</td></tr>
<tr class="memdesc:a78ebb4cd13cdea9917d3e2b7cc3bfbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the output string of the given z3::expr. <br /></td></tr>
<tr class="separator:a78ebb4cd13cdea9917d3e2b7cc3bfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e964690ec5bb80e51e35cb3b73c024"><td class="memItemLeft" align="right" valign="top"><a id="ad4e964690ec5bb80e51e35cb3b73c024"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad4e964690ec5bb80e51e35cb3b73c024">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classilang_1_1_verilog_analyzer_base.html#a218c0476db4d9516652f3cfa104a9d34">VerilogAnalyzerBase::vlg_loc_t</a> &amp;obj)</td></tr>
<tr class="memdesc:ad4e964690ec5bb80e51e35cb3b73c024"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload the operator &lt;&lt; for printing location <br /></td></tr>
<tr class="separator:ad4e964690ec5bb80e51e35cb3b73c024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4730e74d6b322dbcdeccbe4f1d0d14"><td class="memItemLeft" align="right" valign="top"><a id="aeb4730e74d6b322dbcdeccbe4f1d0d14"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TestParseVerilogFrom</b> (const std::string &amp;fn)</td></tr>
<tr class="separator:aeb4730e74d6b322dbcdeccbe4f1d0d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f74b3642834d61cdb33f1d487ae926"><td class="memItemLeft" align="right" valign="top"><a id="a57f74b3642834d61cdb33f1d487ae926"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a57f74b3642834d61cdb33f1d487ae926">_ast_identifier_tostring</a> (ast_identifier id)</td></tr>
<tr class="memdesc:a57f74b3642834d61cdb33f1d487ae926"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper of the ast_identifier_tostring method with basic string type. <br /></td></tr>
<tr class="separator:a57f74b3642834d61cdb33f1d487ae926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the core data structure and APIs for constructing and storing ILA. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2e20af889c24c84475198e2db9937cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e20af889c24c84475198e2db9937cf7">&#9670;&nbsp;</a></span>DEFAULT_UPDATE_METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceilang.html#a2e20af889c24c84475198e2db9937cf7">ilang::DEFAULT_UPDATE_METHOD</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unified ID for default state-update methods to auto-complete ILA models. OLD_VALUE: s_next &lt;- s NONDET_VALUE: s_next &lt;- nondet_func() </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a41b370cb62e6bb2a4abba9b9f482ff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b370cb62e6bb2a4abba9b9f482ff6f">&#9670;&nbsp;</a></span>BoolConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::BoolConst </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bool_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Boolean constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bool_val</td><td>value of the Boolean constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fdb47cd005c9a3512c5aa2047fcb27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdb47cd005c9a3512c5aa2047fcb27c">&#9670;&nbsp;</a></span>BvConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::BvConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>bit_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a bit-vector constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv_val</td><td>value of the bit-vector constant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>data bit-width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a388d56a6951f3e383bcdf0e39a672720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388d56a6951f3e383bcdf0e39a672720">&#9670;&nbsp;</a></span>CheckCompleteness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ilang::CheckCompleteness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>model_ptr_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the model (pointed by model_ptr_) is complete. Completeness means every assignment to input and state corresponds an instruction. </p>

</div>
</div>
<a id="a7eed520a7d8e159cf7188680647cede3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eed520a7d8e159cf7188680647cede3">&#9670;&nbsp;</a></span>CheckDeterminism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ilang::CheckDeterminism </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>model_ptr_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the model (pointed by model_ptr_) is deterministic. Determinism means no more than one instruction can be decoded truth. </p>

</div>
</div>
<a id="a41ee876398e1809694900f2555cd6ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ee876398e1809694900f2555cd6ad9">&#9670;&nbsp;</a></span>CheckEqSameArch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ilang::CheckEqSameArch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two ILAs have an exact same architecture, i.e., at the highest level of hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first ILA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second ILA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>check update if true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a656b2f08edc6fdf198af1ac54756b6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656b2f08edc6fdf198af1ac54756b6ca">&#9670;&nbsp;</a></span>CheckEqSameMicroArch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ilang::CheckEqSameMicroArch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two ILAs have an exact same micro-architecture. That is, they have a same architecture at every level in the hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first ILA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second ILA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>check update if true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa74b423140c9b8a60e1bac56e90ba175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b423140c9b8a60e1bac56e90ba175">&#9670;&nbsp;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>msbv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>lsbv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two bit-vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msbv</td><td>bit-vector on the more-significant side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsbv</td><td>bit-vector on the less-significant side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21b4e6aeabd9ca97928e0aab10648587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b4e6aeabd9ca97928e0aab10648587">&#9670;&nbsp;</a></span>ExportIlaPortable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ilang::ExportIlaPortable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;&#160;</td>
          <td class="paramname"><em>ila</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the ILA portable to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ila</td><td>the source ILA model to export. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>the name of the exported ILA portable (JSON) file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab73a95aa5988d50567c5ff6fe53de913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73a95aa5988d50567c5ff6fe53de913">&#9670;&nbsp;</a></span>Extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract bit-field in the bit-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>the index of the most-significant bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lo</td><td>the index of the least-significant bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717385221eb8322e7b19096ba48d2516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717385221eb8322e7b19096ba48d2516">&#9670;&nbsp;</a></span>Imply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Imply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>ante</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical imply for Booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ante</td><td>antecedent for the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cons</td><td>consequent for the operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29e232d6d5294946f552703a2eca544b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e232d6d5294946f552703a2eca544b">&#9670;&nbsp;</a></span>ImportChildSynthAbstraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::ImportChildSynthAbstraction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ila_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import the synthesized (child-)abstraction from file, under the given parent ILA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>the name of the synthesized child-abstraction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>the parent ILA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ila_name</td><td>the name pf the generated child-ILA. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58cdb6e544ecc6bec6b75edcf51ef694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cdb6e544ecc6bec6b75edcf51ef694">&#9670;&nbsp;</a></span>ImportIlaPortable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_ila.html">Ila</a> ilang::ImportIlaPortable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import the ILA portable from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>the name of the ILA portable (JSON) file to import. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6810cc71b8a884538774f9f0cae4a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6810cc71b8a884538774f9f0cae4a48">&#9670;&nbsp;</a></span>ImportSynthAbsFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> ilang::ImportSynthAbsFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ila_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from file the abstraction from the synthesis engine and convert it into an ILA model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>file name of the abstraction from the synthesis engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ila_name</td><td>name of the created ILA model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generated ILA model. </dd></dl>

</div>
</div>
<a id="aa1380087070c036209a6000d2034586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1380087070c036209a6000d2034586b">&#9670;&nbsp;</a></span>ImportSynthAbsFromFileHier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> ilang::ImportSynthAbsFromFileHier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ila_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from file the abstraction from the synthesis engine and convert it into a child-ILA of the specified parent ILA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>file name of the abstraction from the synthesis engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>pointer to the parent ILA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ila_name</td><td>name of the created ILA model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generated ILA model. </dd></dl>

</div>
</div>
<a id="a74bfc39bc1e23556a38f0bea47a2c6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bfc39bc1e23556a38f0bea47a2c6dc">&#9670;&nbsp;</a></span>ImportSynthAbstraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_ila.html">Ila</a> ilang::ImportSynthAbstraction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ila_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import the synthesized abstraction from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>the name of the synthesized abstraction (.ila) file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ila_name</td><td>the name of the generated ILA. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab63ed74adc72075df524ec933146f0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63ed74adc72075df524ec933146f0f3">&#9670;&nbsp;</a></span>Ite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Ite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If-then-else on the Boolean condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>Boolean type condition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Expression to take when the condition is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Expression to take when the condition is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38808a9aed62a8c4a6917621c9318d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38808a9aed62a8c4a6917621c9318d6e">&#9670;&nbsp;</a></span>LogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::LogLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimun log level. Log messages at or above this level will be logged. (Default: 0) </p>
<ul>
<li>INFO: level 0</li>
<li>WARNING: level 1</li>
<li>ERROR: level 2</li>
<li>FATAL: level 3 </li>
</ul>

</div>
</div>
<a id="a35a459a835293a24f66c8e2fcf35aa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a459a835293a24f66c8e2fcf35aa50">&#9670;&nbsp;</a></span>LRotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::LRotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>immediate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-rotate the bit-vector with immediate number of times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate</td><td>number of times to rotate the bv </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1e7f6d6efdece168ce82d3fa3042d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e7f6d6efdece168ce82d3fa3042d9b">&#9670;&nbsp;</a></span>MemConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::MemConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &amp;&#160;</td>
          <td class="paramname"><em>def_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a>, <a class="el" href="namespaceilang.html#acc1d2afe4c879a45329d57affe54a1db">NumericType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>addr_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>data_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a memory constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">def_val</td><td>default value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>non-default address-data mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_width</td><td>address bit-width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_width</td><td>data bit-width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09d86bebcf221a241039af4bd2f5ee4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d86bebcf221a241039af4bd2f5ee4a">&#9670;&nbsp;</a></span>os_portable_execute_shell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structilang_1_1execute__result.html">execute_result</a> ilang::os_portable_execute_shell </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>redirect_output_file</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceilang.html#a6b3372e18c965cab7e146d01c376a24a">redirect_t</a>&#160;</td>
          <td class="paramname"><em>rdt</em> = <code>redirect_t::BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pid_file_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>execute some executables that are shell scripts, timeout (if 0 will wait forever) </p>

</div>
</div>
<a id="a79f4521ec82c6af4695e31e917082828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f4521ec82c6af4695e31e917082828">&#9670;&nbsp;</a></span>os_portable_file_name_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ilang::os_portable_file_name_from_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract filename from path C:<em></em> <b></b> <code></code>.txt -&gt; c.txt d/e/ghi -&gt; ghi </p>

</div>
</div>
<a id="a7f987f62bad43e9a6876076441c66b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f987f62bad43e9a6876076441c66b6f">&#9670;&nbsp;</a></span>os_portable_path_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ilang::os_portable_path_from_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract path from path C:<em></em> <b></b> <code></code>.txt -&gt; "C:\a\b\ something " C:<em></em> <b></b> <code>-&gt;</code> C:<em></em> <b>d/e/ghi</b> -&gt; "d/e/" </p>

</div>
</div>
<a id="a53f5d61665a892dad75f4db1fbcc5ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f5d61665a892dad75f4db1fbcc5ef0">&#9670;&nbsp;</a></span>ReFindAndDo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; ilang::ReFindAndDo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::string(std::string)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filter out a list of substring by the regular expression, call f each time and use its return value in the list, f can also do something else in itself </p>

</div>
</div>
<a id="abd95e8beb244056395bb6f24dca2173b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd95e8beb244056395bb6f24dca2173b">&#9670;&nbsp;</a></span>RRotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::RRotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>immediate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-rotate the bit-vector with immediate number of times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate</td><td>number of times to rotate the bv </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28a510ed3c6bbe8cb314bdfb8d664283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a510ed3c6bbe8cb314bdfb8d664283">&#9670;&nbsp;</a></span>SelectBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::SelectBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract single bit in the bit-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>the index of the selected bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5002dc8078f121ff03b282d1637b4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5002dc8078f121ff03b282d1637b4c0">&#9670;&nbsp;</a></span>SetLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::SetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimun log level. Log messages at or above this level will be logged. (Default: 0) </p>
<ul>
<li>INFO: level 0</li>
<li>WARNING: level 1</li>
<li>ERROR: level 2</li>
<li>FATAL: level 3 </li>
</ul>

</div>
</div>
<a id="ac40770ca14b70a11f277696dc6c6dff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40770ca14b70a11f277696dc6c6dff2">&#9670;&nbsp;</a></span>SetUnsignedComparison()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::SetUnsignedComparison </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the default behavior of operator &lt;, &lt;=, &gt; and &gt;=, by default, signed compare </p>

</div>
</div>
<a id="ae0a2da11f53d77bc38c204c87f6eecda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a2da11f53d77bc38c204c87f6eecda">&#9670;&nbsp;</a></span>SExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::SExt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign-extend the bit-vector to the specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>bit-width of the extended (result) bit-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad992886a38803601f88f987b174f4c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad992886a38803601f88f987b174f4c34">&#9670;&nbsp;</a></span>ZExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::ZExt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero-extend the bit-vector to the specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>bit-width of the extended (result) bit-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
