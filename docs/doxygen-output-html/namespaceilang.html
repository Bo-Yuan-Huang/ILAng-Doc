<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ilang: ilang Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ilang
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">ILAng: A Modeling and Verification Platform for SoCs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ilang Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_abs_knob.html">AbsKnob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ast.html">Ast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for the Abstract Syntax Tree. An <a class="el" href="classilang_1_1_ast.html" title="The class for the Abstract Syntax Tree. An Ast object can be an expression or function definition (in...">Ast</a> object can be an expression or function definition (interpreted or uninterpreted).  <a href="classilang_1_1_ast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_bool_val.html">BoolVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing Boolean values.  <a href="classilang_1_1_bool_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_bv_val.html">BvVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing Bitvector values.  <a href="classilang_1_1_bv_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_comm_diag.html">CommDiag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator for commutating diagram-based equivalence checking.  <a href="classilang_1_1_comm_diag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_comp_ref_rel.html">CompRefRel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compositional refinement relation defines a unit (element for the composition) of refinement relation, which specifies.  <a href="classilang_1_1_comp_ref_rel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_cosa__problem.html">Cosa_problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to store (and generate) the problem for cosa  <a href="classilang_1_1_cosa__problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_debug_log.html">DebugLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for enabling and disabling debug tags.  <a href="classilang_1_1_debug_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for expression, which is the basic type for variables, constraints, state update expressions, etc.  <a href="classilang_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_const.html">ExprConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for constant values (bool, bv, or memory). Constant should be terminating nodes in the AST.  <a href="classilang_1_1_expr_const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object for hashing <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. The hash value is the id of the symbol, which is supposed to be unique.  <a href="classilang_1_1_expr_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_mngr.html">ExprMngr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifier for AST trees by sharing nodes based on the hash value.  <a href="classilang_1_1_expr_mngr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op.html">ExprOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for operations, e.g. AND, OR, ADD, etc. Operations are non-terminating nodes in the AST.  <a href="classilang_1_1_expr_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_add.html">ExprOpAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned addition.  <a href="classilang_1_1_expr_op_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_and.html">ExprOpAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical AND operation "&amp;".  <a href="classilang_1_1_expr_op_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_app_func.html">ExprOpAppFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for apply uninterpreted function.  <a href="classilang_1_1_expr_op_app_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ashr.html">ExprOpAshr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for arithmetic right shifting a bit-vector.  <a href="classilang_1_1_expr_op_ashr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_compl.html">ExprOpCompl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary bit-wise complement "~". (bv only)  <a href="classilang_1_1_expr_op_compl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_concat.html">ExprOpConcat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for bitvector concatenation.  <a href="classilang_1_1_expr_op_concat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_eq.html">ExprOpEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison EQ "==".  <a href="classilang_1_1_expr_op_eq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_extract.html">ExprOpExtract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for bitvector extraction.  <a href="classilang_1_1_expr_op_extract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_gt.html">ExprOpGt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison signed greater than "&gt;".  <a href="classilang_1_1_expr_op_gt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_imply.html">ExprOpImply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for logical imply.  <a href="classilang_1_1_expr_op_imply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ite.html">ExprOpIte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for if-then-else.  <a href="classilang_1_1_expr_op_ite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_load.html">ExprOpLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for memory load.  <a href="classilang_1_1_expr_op_load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_lshr.html">ExprOpLshr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for logical right shifting a bit-vector.  <a href="classilang_1_1_expr_op_lshr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_lt.html">ExprOpLt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison signed less than "&lt;".  <a href="classilang_1_1_expr_op_lt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_neg.html">ExprOpNeg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary negate operation "-".  <a href="classilang_1_1_expr_op_neg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_not.html">ExprOpNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary not operation "!". (bool only)  <a href="classilang_1_1_expr_op_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_or.html">ExprOpOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical OR operation "|".  <a href="classilang_1_1_expr_op_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_s_ext.html">ExprOpSExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calss wrapper for sign-extend.  <a href="classilang_1_1_expr_op_s_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_shl.html">ExprOpShl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for left shifting a bit-vector.  <a href="classilang_1_1_expr_op_shl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_store.html">ExprOpStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for memory store.  <a href="classilang_1_1_expr_op_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_sub.html">ExprOpSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned subtraction.  <a href="classilang_1_1_expr_op_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ugt.html">ExprOpUgt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison unsigned greater than.  <a href="classilang_1_1_expr_op_ugt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ult.html">ExprOpUlt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison unsigned less than.  <a href="classilang_1_1_expr_op_ult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_xor.html">ExprOpXor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical XOR operation "^".  <a href="classilang_1_1_expr_op_xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_z_ext.html">ExprOpZExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for zero-extend.  <a href="classilang_1_1_expr_op_z_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a> (e.g. state var, var relation, constant, etc).  <a href="classilang_1_1_expr_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_var.html">ExprVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for variables (bool, bv, or mem). Variable should be the terminating nodes in the AST.  <a href="classilang_1_1_expr_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func.html">Func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for uninterpreted function.  <a href="classilang_1_1_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_flat_ila.html">FuncObjFlatIla</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for flatten ILA tree. There is currently a problem: this func obj calls duplInst which in turn uses rewriteExpr and rewriteExpr does not change the host of of state variables, so the flatten expression still has the host pointed to their original ILA. This is fine for Verilog Gen, which only depends on variable names to generate variables but may not be good enough for other purpose.  <a href="classilang_1_1_func_obj_flat_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_rewr_expr.html">FuncObjRewrExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for rewriting <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>.  <a href="classilang_1_1_func_obj_rewr_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_rewr_ila.html">FuncObjRewrIla</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for rewriting ILA tree.  <a href="classilang_1_1_func_obj_rewr_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_ref.html">FuncRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_func.html" title="The class for uninterpreted function. ">Func</a> (uninterpreted function).  <a href="classilang_1_1_func_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_host_remove_restore.html">HostRemoveRestore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to remove and restore the host info This is useful as we want the ast with the same name generates the same z3 expr. This framework is based on an assumption that if we call z3 to create the variable of the same name multiple times they refer to the same one internally. FIXME: Need to check this assumption if we want to support other SMT solvers!  <a href="classilang_1_1_host_remove_restore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila.html">Ila</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains: ">InstrLvlAbs</a> (ILA).  <a href="classilang_1_1_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila_z3_unroller.html">IlaZ3Unroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of generating z3::expr for verification.  <a href="classilang_1_1_ila_z3_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr.html">Instr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for the Instruction. An <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains: ">Instr</a> object contains:  <a href="classilang_1_1_instr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_lvl_abs.html">InstrLvlAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of Instruction-Level Abstraction (ILA). An ILA contains:  <a href="classilang_1_1_instr_lvl_abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_ref.html">InstrRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains: ">Instr</a> (instruction).  <a href="classilang_1_1_instr_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_seq.html">InstrSeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction Sequencing does:  <a href="classilang_1_1_instr_seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_tran_edge.html">InstrTranEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction transition edge, includeing:  <a href="classilang_1_1_instr_tran_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_tran_node.html">InstrTranNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node for instruction-transition node, each node represent an instruction.  <a href="classilang_1_1_instr_tran_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inteface_directive_recorder.html">IntefaceDirectiveRecorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in Verilog Verification Target Generation for dealing with interface directives.  <a href="classilang_1_1_inteface_directive_recorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html">InterIlaUnroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for unrolling multiple ILAs. There are two ways of unrolling: ordered and unordered. Ordered unrolling assumes an ordered program template, despite that some may not exist in the final outcome. By default the state with the same name among ILAs is considered as the same shared state.  <a href="classilang_1_1_inter_ila_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_key_vec.html">KeyVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container that support key search and index access.  <a href="classilang_1_1_key_vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_key_vec_it.html">KeyVecIt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudo-iterator for the key-search vector.  <a href="classilang_1_1_key_vec_it.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_legacy_bmc.html">LegacyBmc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified bounded model checking engine for ILAs.  <a href="classilang_1_1_legacy_bmc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_log_initter.html">LogInitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-time class for initializing GLog.  <a href="classilang_1_1_log_initter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_map_set.html">MapSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map for sets.  <a href="classilang_1_1_map_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_memory_model.html">MemoryModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for memory models.  <a href="classilang_1_1_memory_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_mem_val.html">MemVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing memory (array) values.  <a href="classilang_1_1_mem_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_mono_unroll.html">MonoUnroll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application class for unrolling the ILA as a monolithic transition system.  <a href="classilang_1_1_mono_unroll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_nested_mem_addr_data_avoider.html">NestedMemAddrDataAvoider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of traversing to avoid nested memory access in address.  <a href="classilang_1_1_nested_mem_addr_data_avoider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basest type in the ILA structure. It can be either <a class="el" href="classilang_1_1_ast.html" title="The class for the Abstract Syntax Tree. An Ast object can be an expression or function definition (in...">Ast</a>, <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains: ">Instr</a>, or <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains: ">InstrLvlAbs</a>.  <a href="classilang_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_path_unroll.html">PathUnroll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application class for unrolling a path of instruction sequence.  <a href="classilang_1_1_path_unroll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_portable_mngr.html">PortableMngr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for exporting and importing ILA portable in JSON format.  <a href="classilang_1_1_portable_mngr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_refinement_map.html">RefinementMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement mapping defines how to map micro-architectural states to architectural states for comparison.  <a href="classilang_1_1_refinement_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_relation_map.html">RelationMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relation mapping defines how arch states of two models are mapped, i.e., state mapping.  <a href="classilang_1_1_relation_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sc.html">Sc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO.  <a href="classilang_1_1_sc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sc_trace_step.html">ScTraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO trace step.  <a href="classilang_1_1_sc_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_base.html">SignalInfoBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold signal info.  <a href="classilang_1_1_signal_info_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_port.html">SignalInfoPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to convert port to signal info.  <a href="classilang_1_1_signal_info_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_reg.html">SignalInfoReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to convert reg to signal info.  <a href="classilang_1_1_signal_info_reg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_signal_info_wire.html">SignalInfoWire</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to convert wire to signal info.  <a href="classilang_1_1_signal_info_wire.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort.html">Sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for sort (type for expr, and the range/domain of functions).  <a href="classilang_1_1_sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_bool.html">SortBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of Boolean <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions). ">Sort</a>.  <a href="classilang_1_1_sort_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_bv.html">SortBv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of bit-vector <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions). ">Sort</a>.  <a href="classilang_1_1_sort_bv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_mem.html">SortMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of memory (array) <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions). ">Sort</a>.  <a href="classilang_1_1_sort_mem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_ref.html">SortRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions). ">Sort</a> (type for different AST nodes).  <a href="classilang_1_1_sort_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_state_mapping_directive_recorder.html">StateMappingDirectiveRecorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to handle state mapping directives in the refinement relations  <a href="classilang_1_1_state_mapping_directive_recorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_symbol.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symbol is the name and ID of an object. Every object has an unique symbol.  <a href="classilang_1_1_symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_synth_abs_converter.html">SynthAbsConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for converting an abstraction from the synthesis engine to an ILA model.  <a href="classilang_1_1_synth_abs_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_trace_step.html">TraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for trace step (an instance of instruction) As in the unrolling, there may be multiple instances of the same instructions, so we have the trace steps.  <a href="classilang_1_1_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_tso.html">Tso</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO.  <a href="classilang_1_1_tso.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_tso_trace_step.html">TsoTraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO trace step.  <a href="classilang_1_1_tso_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_unroller.html">Unroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for unrolling ILA execution in different settings.  <a href="classilang_1_1_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base type for constant value.  <a href="classilang_1_1_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_var_extractor.html">VarExtractor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_var_use_finder.html">VarUseFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of finding variable uses. So that we don't need to create pi variables for unused state variables. FIXME: currently there is no need to make a class for it, but in the future it is possible to use a hash table to avoid traverse the same sub-tree twice.  <a href="classilang_1_1_var_use_finder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_analyzer.html">VerilogAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for Verilog analysis.  <a href="classilang_1_1_verilog_analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_analyzer_base.html">VerilogAnalyzerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classilang_1_1_verilog_analyzer_base.html" title="VerilogAnalyzerBase should never be instantiated, only used as a pointer type in class VerilogInfo...">VerilogAnalyzerBase</a> should never be instantiated, only used as a pointer type in class <a class="el" href="classilang_1_1_verilog_info.html" title="The class that invoke the analyzer. ">VerilogInfo</a>.  <a href="classilang_1_1_verilog_analyzer_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_generator.html">VerilogGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Verilog Generator.  <a href="classilang_1_1_verilog_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_generator_base.html">VerilogGeneratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of <a class="el" href="classilang_1_1_verilog_generator.html" title="Class of Verilog Generator. ">VerilogGenerator</a>.  <a href="classilang_1_1_verilog_generator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_info.html">VerilogInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class that invoke the analyzer.  <a href="classilang_1_1_verilog_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_modifier.html">VerilogModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the class for modification to verilog  <a href="classilang_1_1_verilog_modifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_verification_target_generator.html">VerilogVerificationTargetGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structilang_1_1_vlg_abs_mem.html">VlgAbsMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a struct to store abstract memory  <a href="structilang_1_1_vlg_abs_mem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_sgl_tgt_gen.html">VlgSglTgtGen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a target (just the invairant or for an instruction)  <a href="classilang_1_1_vlg_sgl_tgt_gen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_sgl_tgt_gen___cosa.html">VlgSglTgtGen_Cosa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to interface w. COSA  <a href="classilang_1_1_vlg_sgl_tgt_gen___cosa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_sgl_tgt_gen___jasper.html">VlgSglTgtGen_Jasper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verilog Verification Target Generator &ndash; for JasperGold Unlike for cosa, we don't need a separate file although we do have some ...  <a href="classilang_1_1_vlg_sgl_tgt_gen___jasper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_verif_tgt_gen.html">VlgVerifTgtGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_vlg_verif_tgt_gen_base.html">VlgVerifTgtGenBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classilang_1_1_vlg_verif_tgt_gen_base.html" title="VlgVerifTgtGenBase: do nothing, should not instantiate. ">VlgVerifTgtGenBase</a>: do nothing, should not instantiate.  <a href="classilang_1_1_vlg_verif_tgt_gen_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_z3_expr_adapter.html">Z3ExprAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for generating z3 expression from an ILA.  <a href="classilang_1_1_z3_expr_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="memItemLeft" align="right" valign="top"><a id="a7c4196c72e53ea4df4b7861af7bc3bce"></a>
typedef <a class="el" href="classilang_1_1_expr.html#a85952b6a34620c4c8cab6bac9c9fdf8c">Expr::ExprPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a></td></tr>
<tr class="memdesc:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="memItemLeft" align="right" valign="top"><a id="a95d222bcc4d46261cbf6dbc18a3f5e11"></a>
typedef <a class="el" href="classilang_1_1_expr.html#a17efc8282f647681d37cd4c78928aa01">Expr::ExprPtrVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a95d222bcc4d46261cbf6dbc18a3f5e11">ExprPtrVec</a></td></tr>
<tr class="memdesc:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e6475e04844bcad9c380aac0b215c"><td class="memItemLeft" align="right" valign="top"><a id="ad40e6475e04844bcad9c380aac0b215c"></a>
typedef std::unordered_map&lt; const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad40e6475e04844bcad9c380aac0b215c">ExprMap</a></td></tr>
<tr class="memdesc:ad40e6475e04844bcad9c380aac0b215c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for mapping between <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:ad40e6475e04844bcad9c380aac0b215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54732171848dbcb975458e689024a04c"><td class="memItemLeft" align="right" valign="top"><a id="a54732171848dbcb975458e689024a04c"></a>
typedef std::unordered_set&lt; <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a54732171848dbcb975458e689024a04c">ExprSet</a></td></tr>
<tr class="memdesc:a54732171848dbcb975458e689024a04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a54732171848dbcb975458e689024a04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6140a3823254564a0e81db8b3afea25c"><td class="memItemLeft" align="right" valign="top"><a id="a6140a3823254564a0e81db8b3afea25c"></a>
typedef <a class="el" href="classilang_1_1_func.html#a91aa192ceb8b9025423fdb95c8429282">Func::FuncPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6140a3823254564a0e81db8b3afea25c">FuncPtr</a></td></tr>
<tr class="memdesc:a6140a3823254564a0e81db8b3afea25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_func.html" title="The class for uninterpreted function. ">Func</a>. <br /></td></tr>
<tr class="separator:a6140a3823254564a0e81db8b3afea25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01073336878d60a231f4fe96d45ab55"><td class="memItemLeft" align="right" valign="top"><a id="ae01073336878d60a231f4fe96d45ab55"></a>
typedef <a class="el" href="classilang_1_1_sort.html#a8b9cc5e381404211a1c0423327866d3b">Sort::SortPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae01073336878d60a231f4fe96d45ab55">SortPtr</a></td></tr>
<tr class="memdesc:ae01073336878d60a231f4fe96d45ab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for storing/passing <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions). ">Sort</a>. <br /></td></tr>
<tr class="separator:ae01073336878d60a231f4fe96d45ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="memItemLeft" align="right" valign="top"><a id="ad512edf5ea3912c37cb9c9a4a47d09d0"></a>
typedef <a class="el" href="classilang_1_1_value.html#af7f5423825f03fdb5f62d2598778d644">Value::ValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad512edf5ea3912c37cb9c9a4a47d09d0">ValPtr</a></td></tr>
<tr class="memdesc:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_value.html" title="The base type for constant value. ">Value</a>. <br /></td></tr>
<tr class="separator:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dabeb8fdac011892c311e074696b570"><td class="memItemLeft" align="right" valign="top"><a id="a8dabeb8fdac011892c311e074696b570"></a>
typedef <a class="el" href="classilang_1_1_bool_val.html#aba4dff009d7d7f6c0a879312dbb23ba3">BoolVal::BoolValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8dabeb8fdac011892c311e074696b570">BoolValPtr</a></td></tr>
<tr class="memdesc:a8dabeb8fdac011892c311e074696b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_bool_val.html" title="The container for representing Boolean values. ">BoolVal</a>. <br /></td></tr>
<tr class="separator:a8dabeb8fdac011892c311e074696b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b38d4e87534db4ff8b793d11d1d950"><td class="memItemLeft" align="right" valign="top"><a id="af9b38d4e87534db4ff8b793d11d1d950"></a>
typedef <a class="el" href="classilang_1_1_bv_val.html#a880f2d0a32113b4cc4f5faa05e3c3b4a">BvVal::BvValType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af9b38d4e87534db4ff8b793d11d1d950">BvValType</a></td></tr>
<tr class="memdesc:af9b38d4e87534db4ff8b793d11d1d950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for storing <a class="el" href="classilang_1_1_bv_val.html" title="The container for representing Bitvector values. ">BvVal</a>. <br /></td></tr>
<tr class="separator:af9b38d4e87534db4ff8b793d11d1d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a892f6286748cb7548429984d840752"><td class="memItemLeft" align="right" valign="top"><a id="a6a892f6286748cb7548429984d840752"></a>
typedef <a class="el" href="classilang_1_1_bv_val.html#a07cd315cb7e6d40ec7fef2b00989b074">BvVal::BvValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6a892f6286748cb7548429984d840752">BvValPtr</a></td></tr>
<tr class="memdesc:a6a892f6286748cb7548429984d840752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_bv_val.html" title="The container for representing Bitvector values. ">BvVal</a>. <br /></td></tr>
<tr class="separator:a6a892f6286748cb7548429984d840752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="memItemLeft" align="right" valign="top"><a id="a4fd677b2cf7cb4e83a1e81f35e9aec6b"></a>
typedef <a class="el" href="classilang_1_1_mem_val.html#a9a2bf21ab1aa0d15fcb9024025a1487e">MemVal::MemValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4fd677b2cf7cb4e83a1e81f35e9aec6b">MemValPtr</a></td></tr>
<tr class="memdesc:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_mem_val.html" title="The container for representing memory (array) values. ">MemVal</a>. <br /></td></tr>
<tr class="separator:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63554514c4dc658062d446051c78882"><td class="memItemLeft" align="right" valign="top"><a id="aa63554514c4dc658062d446051c78882"></a>
typedef <a class="el" href="classilang_1_1_mem_val.html#aea3cddbc760f2e143d02cdfab66e6b36">MemVal::MemValMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa63554514c4dc658062d446051c78882">MemValMap</a></td></tr>
<tr class="memdesc:aa63554514c4dc658062d446051c78882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing the address/data mapping. <br /></td></tr>
<tr class="separator:aa63554514c4dc658062d446051c78882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a114dcaa252083440129309151528"><td class="memItemLeft" align="right" valign="top"><a id="a540a114dcaa252083440129309151528"></a>
typedef <a class="el" href="classilang_1_1_refinement_map.html#ab988c650cef076c777dd0200e8dab51f">RefinementMap::RefPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a540a114dcaa252083440129309151528">RefPtr</a></td></tr>
<tr class="memdesc:a540a114dcaa252083440129309151528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the refinement mapping. <br /></td></tr>
<tr class="separator:a540a114dcaa252083440129309151528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="memItemLeft" align="right" valign="top"><a id="adca57fadf3c1f00dba124eb1ec56e6e9"></a>
typedef <a class="el" href="classilang_1_1_relation_map.html#adfdefb173e77fc29073c233aa3ccdbd2">RelationMap::RelPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adca57fadf3c1f00dba124eb1ec56e6e9">RelPtr</a></td></tr>
<tr class="memdesc:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the relation mapping. <br /></td></tr>
<tr class="separator:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="memItemLeft" align="right" valign="top"><a id="a3c2c096b87ad7a9475c5a32315c18ba6"></a>
typedef <a class="el" href="classilang_1_1_comp_ref_rel.html#a9081b437a14b3a2edef9d30b000ea535">CompRefRel::CrrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a3c2c096b87ad7a9475c5a32315c18ba6">CrrPtr</a></td></tr>
<tr class="memdesc:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the compositional relation mapping. <br /></td></tr>
<tr class="separator:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4eee919aa24fff882d03a48d733c19"><td class="memItemLeft" align="right" valign="top"><a id="adc4eee919aa24fff882d03a48d733c19"></a>
typedef std::vector&lt; z3::expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc4eee919aa24fff882d03a48d733c19">Z3ExprVec</a></td></tr>
<tr class="memdesc:adc4eee919aa24fff882d03a48d733c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type for z3 expression. <br /></td></tr>
<tr class="separator:adc4eee919aa24fff882d03a48d733c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9ddf66d424d9d9544db761963a5836"><td class="memItemLeft" align="right" valign="top"><a id="aca9ddf66d424d9d9544db761963a5836"></a>
typedef std::shared_ptr&lt; <a class="el" href="namespaceilang.html#adc4eee919aa24fff882d03a48d733c19">Z3ExprVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aca9ddf66d424d9d9544db761963a5836">Z3ExprVecPtr</a></td></tr>
<tr class="memdesc:aca9ddf66d424d9d9544db761963a5836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer for the z3 expression vector. <br /></td></tr>
<tr class="separator:aca9ddf66d424d9d9544db761963a5836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e34b145b7ce30f509c336c32013c097"><td class="memItemLeft" align="right" valign="top"><a id="a9e34b145b7ce30f509c336c32013c097"></a>
typedef <a class="el" href="classilang_1_1_key_vec.html">KeyVec</a>&lt; <a class="el" href="classilang_1_1_symbol.html">Symbol</a>, z3::expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9e34b145b7ce30f509c336c32013c097">Z3ExprMap</a></td></tr>
<tr class="memdesc:a9e34b145b7ce30f509c336c32013c097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map type for z3 expression. <br /></td></tr>
<tr class="separator:a9e34b145b7ce30f509c336c32013c097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aa5111edd013874f3cfd7de9bf11bc"><td class="memItemLeft" align="right" valign="top"><a id="a96aa5111edd013874f3cfd7de9bf11bc"></a>
typedef std::shared_ptr&lt; <a class="el" href="namespaceilang.html#a9e34b145b7ce30f509c336c32013c097">Z3ExprMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a96aa5111edd013874f3cfd7de9bf11bc">Z3ExprMapPtr</a></td></tr>
<tr class="memdesc:a96aa5111edd013874f3cfd7de9bf11bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer for the z3 expression map. <br /></td></tr>
<tr class="separator:a96aa5111edd013874f3cfd7de9bf11bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee5051111191e26d672ae214bcf3e1b"><td class="memItemLeft" align="right" valign="top"><a id="a4ee5051111191e26d672ae214bcf3e1b"></a>
typedef <a class="el" href="classilang_1_1_expr_mngr.html#ad35ebf0cecad6f10877667b766bdfac1">ExprMngr::ExprMngrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4ee5051111191e26d672ae214bcf3e1b">ExprMngrPtr</a></td></tr>
<tr class="memdesc:a4ee5051111191e26d672ae214bcf3e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing shared ast simplifier. <br /></td></tr>
<tr class="separator:a4ee5051111191e26d672ae214bcf3e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88a19312ae653d687a0d1207bb284f6"><td class="memItemLeft" align="right" valign="top"><a id="af88a19312ae653d687a0d1207bb284f6"></a>
typedef <a class="el" href="classilang_1_1_instr.html#af43ebb1fe223b369e42b5600f902b4b4">Instr::InstrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af88a19312ae653d687a0d1207bb284f6">InstrPtr</a></td></tr>
<tr class="memdesc:af88a19312ae653d687a0d1207bb284f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains: ">Instr</a>. <br /></td></tr>
<tr class="separator:af88a19312ae653d687a0d1207bb284f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13249a9b1d22eb3454730a7903be4364"><td class="memItemLeft" align="right" valign="top"><a id="a13249a9b1d22eb3454730a7903be4364"></a>
typedef std::shared_ptr&lt; const <a class="el" href="classilang_1_1_instr.html">Instr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a13249a9b1d22eb3454730a7903be4364">InstrCnstPtr</a></td></tr>
<tr class="memdesc:a13249a9b1d22eb3454730a7903be4364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for read-only use of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains: ">Instr</a>. <br /></td></tr>
<tr class="separator:a13249a9b1d22eb3454730a7903be4364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e6555f156373812f16030b98c42e65"><td class="memItemLeft" align="right" valign="top"><a id="a35e6555f156373812f16030b98c42e65"></a>
typedef std::vector&lt; <a class="el" href="namespaceilang.html#af88a19312ae653d687a0d1207bb284f6">InstrPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a35e6555f156373812f16030b98c42e65">InstrVec</a></td></tr>
<tr class="memdesc:a35e6555f156373812f16030b98c42e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains: ">Instr</a>. <br /></td></tr>
<tr class="separator:a35e6555f156373812f16030b98c42e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b30fdf347e493b3937143da05d1a72"><td class="memItemLeft" align="right" valign="top"><a id="ad1b30fdf347e493b3937143da05d1a72"></a>
typedef <a class="el" href="classilang_1_1_instr_lvl_abs.html#a743fd98e5ad145d70cb0dabf8db0007c">InstrLvlAbs::InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a></td></tr>
<tr class="memdesc:ad1b30fdf347e493b3937143da05d1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains: ">InstrLvlAbs</a>. <br /></td></tr>
<tr class="separator:ad1b30fdf347e493b3937143da05d1a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc86156b73aa1a4b6369645e9b96ff19"><td class="memItemLeft" align="right" valign="top"><a id="adc86156b73aa1a4b6369645e9b96ff19"></a>
typedef <a class="el" href="classilang_1_1_instr_lvl_abs.html#a57464e2e6a69327715fa88963ebfb282">InstrLvlAbs::InstrLvlAbsCnstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc86156b73aa1a4b6369645e9b96ff19">InstrLvlAbsCnstPtr</a></td></tr>
<tr class="memdesc:adc86156b73aa1a4b6369645e9b96ff19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for read-only usage of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains: ">InstrLvlAbs</a>. <br /></td></tr>
<tr class="separator:adc86156b73aa1a4b6369645e9b96ff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e780d7b16cb21d2c10f955c504e7356"><td class="memItemLeft" align="right" valign="top"><a id="a4e780d7b16cb21d2c10f955c504e7356"></a>
typedef std::map&lt; <a class="el" href="namespaceilang.html#adc86156b73aa1a4b6369645e9b96ff19">InstrLvlAbsCnstPtr</a>, <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4e780d7b16cb21d2c10f955c504e7356">CnstIlaMap</a></td></tr>
<tr class="memdesc:a4e780d7b16cb21d2c10f955c504e7356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a mapping from constant ILA ptr to ILA ptr. <br /></td></tr>
<tr class="separator:a4e780d7b16cb21d2c10f955c504e7356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc547f597d2a58cf82dfe756fe092d86"><td class="memItemLeft" align="right" valign="top"><a id="adc547f597d2a58cf82dfe756fe092d86"></a>
typedef <a class="el" href="classilang_1_1_object.html#af23d3767cfbc8cb9312281cbfa4aae48">Object::ObjPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc547f597d2a58cf82dfe756fe092d86">ObjPtr</a></td></tr>
<tr class="memdesc:adc547f597d2a58cf82dfe756fe092d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_object.html" title="The basest type in the ILA structure. It can be either Ast, Instr, or InstrLvlAbs. ">Object</a>. <br /></td></tr>
<tr class="separator:adc547f597d2a58cf82dfe756fe092d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7c382e8a666b516fc761b0ce8bff8"><td class="memItemLeft" align="right" valign="top"><a id="a61e7c382e8a666b516fc761b0ce8bff8"></a>
typedef <a class="el" href="classilang_1_1_instr_seq.html#a37dd168ce5d95507eb7bf53455d79b80">InstrSeq::InstrSeqPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a61e7c382e8a666b516fc761b0ce8bff8">InstrSeqPtr</a></td></tr>
<tr class="memdesc:a61e7c382e8a666b516fc761b0ce8bff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around <a class="el" href="classilang_1_1_instr_seq.html" title="Instruction Sequencing does: ">InstrSeq</a>. <br /></td></tr>
<tr class="separator:a61e7c382e8a666b516fc761b0ce8bff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e2a4ef111b96f327b76f11e86b01a"><td class="memItemLeft" align="right" valign="top"><a id="a784e2a4ef111b96f327b76f11e86b01a"></a>
typedef <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a784e2a4ef111b96f327b76f11e86b01a">Z3AdapterHash</a></td></tr>
<tr class="memdesc:a784e2a4ef111b96f327b76f11e86b01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object for hashing <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a> in generating z3 expression. <br /></td></tr>
<tr class="separator:a784e2a4ef111b96f327b76f11e86b01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9447fa13b525405d092d22eb0566edcb"><td class="memItemLeft" align="right" valign="top"><a id="a9447fa13b525405d092d22eb0566edcb"></a>
typedef <a class="el" href="classilang_1_1_portable_mngr.html#aa4780430bc807fb5f3bf80991266ffe6">PortableMngr::PortableMngrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9447fa13b525405d092d22eb0566edcb">PortableMngrPtr</a></td></tr>
<tr class="memdesc:a9447fa13b525405d092d22eb0566edcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_portable_mngr.html" title="The class for exporting and importing ILA portable in JSON format. ">PortableMngr</a>. <br /></td></tr>
<tr class="separator:a9447fa13b525405d092d22eb0566edcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e72f6051594b2a8c58f6ad6ee59df1"><td class="memItemLeft" align="right" valign="top"><a id="ab0e72f6051594b2a8c58f6ad6ee59df1"></a>
typedef <a class="el" href="classilang_1_1_synth_abs_converter.html#a4ea7491df29005572c22aae8786db092">SynthAbsConverter::SynthAbsConverterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab0e72f6051594b2a8c58f6ad6ee59df1">SynthAbsConverterPtr</a></td></tr>
<tr class="memdesc:ab0e72f6051594b2a8c58f6ad6ee59df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_synth_abs_converter.html" title="The class for converting an abstraction from the synthesis engine to an ILA model. ">SynthAbsConverter</a>. <br /></td></tr>
<tr class="separator:ab0e72f6051594b2a8c58f6ad6ee59df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3529ea370d3252b9e44e20b53532e"><td class="memItemLeft" align="right" valign="top"><a id="a6ae3529ea370d3252b9e44e20b53532e"></a>
typedef <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VerilogGenHash</b></td></tr>
<tr class="separator:a6ae3529ea370d3252b9e44e20b53532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab4dc990a0af528177f6f90b63bd208c7"><td class="memItemLeft" align="right" valign="top"><a id="ab4dc990a0af528177f6f90b63bd208c7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab4dc990a0af528177f6f90b63bd208c7">AccessType</a> { <b>READ</b>, 
<b>WRITE</b>, 
<b>EITHER</b>
 }<tr class="memdesc:ab4dc990a0af528177f6f90b63bd208c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of state read or write. <br /></td></tr>
</td></tr>
<tr class="separator:ab4dc990a0af528177f6f90b63bd208c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb374202f0c669bea0a49b87d8dee143"><td class="memItemLeft" align="right" valign="top"><a id="aeb374202f0c669bea0a49b87d8dee143"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeb374202f0c669bea0a49b87d8dee143">KeyVecItVal</a> { <b>END</b>, 
<b>FOUND</b>
 }<tr class="memdesc:aeb374202f0c669bea0a49b87d8dee143"><td class="mdescLeft">&#160;</td><td class="mdescRight">KeyVecItVal. <br /></td></tr>
</td></tr>
<tr class="separator:aeb374202f0c669bea0a49b87d8dee143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38808a9aed62a8c4a6917621c9318d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a38808a9aed62a8c4a6917621c9318d6e">LogLevel</a> (const int &amp;lvl)</td></tr>
<tr class="memdesc:a38808a9aed62a8c4a6917621c9318d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimun log level. Log messages at or above this level will be logged. (Default: 0)  <a href="#a38808a9aed62a8c4a6917621c9318d6e">More...</a><br /></td></tr>
<tr class="separator:a38808a9aed62a8c4a6917621c9318d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="memItemLeft" align="right" valign="top"><a id="a04b0d31076d694adcb6b1ee0a475c9dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a04b0d31076d694adcb6b1ee0a475c9dd">LogPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path for log file. If specified, logfiles are written into this directory instead of the default logging directory (/tmp). <br /></td></tr>
<tr class="separator:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d33dbd65f2036041b06be22c830592b"><td class="memItemLeft" align="right" valign="top"><a id="a7d33dbd65f2036041b06be22c830592b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7d33dbd65f2036041b06be22c830592b">LogToErr</a> (bool to_err)</td></tr>
<tr class="memdesc:a7d33dbd65f2036041b06be22c830592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe log to stderr. Log messages to stderr instead of logfiles, if set to 1. <br /></td></tr>
<tr class="separator:a7d33dbd65f2036041b06be22c830592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596c444f0d40287ee7b91263d6ab91c"><td class="memItemLeft" align="right" valign="top"><a id="af596c444f0d40287ee7b91263d6ab91c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af596c444f0d40287ee7b91263d6ab91c">EnableDebug</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:af596c444f0d40287ee7b91263d6ab91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a debug tag. <br /></td></tr>
<tr class="separator:af596c444f0d40287ee7b91263d6ab91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="memItemLeft" align="right" valign="top"><a id="a7b96e3e4622bcefd2d1159766a2df3d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7b96e3e4622bcefd2d1159766a2df3d8">DisableDebug</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a debug tag. <br /></td></tr>
<tr class="separator:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48e47567031b28aa1b58b82e40f60d1"><td class="memItemLeft" align="right" valign="top"><a id="ad48e47567031b28aa1b58b82e40f60d1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad48e47567031b28aa1b58b82e40f60d1">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:ad48e47567031b28aa1b58b82e40f60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic negate for bit-vectors. <br /></td></tr>
<tr class="separator:ad48e47567031b28aa1b58b82e40f60d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc8204049fd3920b75bd255c3c18f74"><td class="memItemLeft" align="right" valign="top"><a id="abdc8204049fd3920b75bd255c3c18f74"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abdc8204049fd3920b75bd255c3c18f74">operator!</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:abdc8204049fd3920b75bd255c3c18f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not for Booleans. <br /></td></tr>
<tr class="separator:abdc8204049fd3920b75bd255c3c18f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="memItemLeft" align="right" valign="top"><a id="a2fb9f43d4ffd7d0cb2061095d1986cbf"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2fb9f43d4ffd7d0cb2061095d1986cbf">operator~</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise complement for bit-vectors. <br /></td></tr>
<tr class="separator:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7282e60e89ef9907cc25254e9dd522"><td class="memItemLeft" align="right" valign="top"><a id="a6c7282e60e89ef9907cc25254e9dd522"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6c7282e60e89ef9907cc25254e9dd522">operator &amp;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a6c7282e60e89ef9907cc25254e9dd522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:a6c7282e60e89ef9907cc25254e9dd522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="memItemLeft" align="right" valign="top"><a id="a7e4d71727922a8e7cd35bf2f9814c6f8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7e4d71727922a8e7cd35bf2f9814c6f8">operator|</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72e1b0d70d982d3a846436152aef3bc"><td class="memItemLeft" align="right" valign="top"><a id="ad72e1b0d70d982d3a846436152aef3bc"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad72e1b0d70d982d3a846436152aef3bc">operator^</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ad72e1b0d70d982d3a846436152aef3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical XOR (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:ad72e1b0d70d982d3a846436152aef3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28e98c027804fa9307f199552870e86"><td class="memItemLeft" align="right" valign="top"><a id="ae28e98c027804fa9307f199552870e86"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae28e98c027804fa9307f199552870e86">operator&lt;&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ae28e98c027804fa9307f199552870e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift for bit-vectors. <br /></td></tr>
<tr class="separator:ae28e98c027804fa9307f199552870e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1848641ecc2609af5de3888328eddb8"><td class="memItemLeft" align="right" valign="top"><a id="ac1848641ecc2609af5de3888328eddb8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac1848641ecc2609af5de3888328eddb8">operator&gt;&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ac1848641ecc2609af5de3888328eddb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic right shift for bit-vectors. <br /></td></tr>
<tr class="separator:ac1848641ecc2609af5de3888328eddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd757988bbf08aa6ab6395f65de46a"><td class="memItemLeft" align="right" valign="top"><a id="acffd757988bbf08aa6ab6395f65de46a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acffd757988bbf08aa6ab6395f65de46a">Lshr</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:acffd757988bbf08aa6ab6395f65de46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical right shift for bit-vectors. <br /></td></tr>
<tr class="separator:acffd757988bbf08aa6ab6395f65de46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="memItemLeft" align="right" valign="top"><a id="a4a9fbd2386191e9a476af6dbae9ac4d1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4a9fbd2386191e9a476af6dbae9ac4d1">operator+</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned addition for bit-vectors. <br /></td></tr>
<tr class="separator:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28362d954dc9512c7292ef91df694e37"><td class="memItemLeft" align="right" valign="top"><a id="a28362d954dc9512c7292ef91df694e37"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a28362d954dc9512c7292ef91df694e37">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a28362d954dc9512c7292ef91df694e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned subtraction for bit-vectors. <br /></td></tr>
<tr class="separator:a28362d954dc9512c7292ef91df694e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d966b396169287ed8d4e734526d22"><td class="memItemLeft" align="right" valign="top"><a id="a879d966b396169287ed8d4e734526d22"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a879d966b396169287ed8d4e734526d22">operator &amp;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:a879d966b396169287ed8d4e734526d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND with Boolean constant. <br /></td></tr>
<tr class="separator:a879d966b396169287ed8d4e734526d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="memItemLeft" align="right" valign="top"><a id="af4ad583ce28ae8f0a7acb3567d00d11a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af4ad583ce28ae8f0a7acb3567d00d11a">operator|</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR with Boolean constant. <br /></td></tr>
<tr class="separator:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4e16eacbe789ffa001734f64c4247"><td class="memItemLeft" align="right" valign="top"><a id="a8bd4e16eacbe789ffa001734f64c4247"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8bd4e16eacbe789ffa001734f64c4247">operator^</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:a8bd4e16eacbe789ffa001734f64c4247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical XOR with Boolean constant. <br /></td></tr>
<tr class="separator:a8bd4e16eacbe789ffa001734f64c4247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="memItemLeft" align="right" valign="top"><a id="a9ce724b1e6f1d4fe10e8b4749df344f1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9ce724b1e6f1d4fe10e8b4749df344f1">operator&lt;&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift with int constant. <br /></td></tr>
<tr class="separator:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1919952d428702d64090f2ea81fa8"><td class="memItemLeft" align="right" valign="top"><a id="a0bb1919952d428702d64090f2ea81fa8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0bb1919952d428702d64090f2ea81fa8">operator&gt;&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a0bb1919952d428702d64090f2ea81fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic right shift with int constant. <br /></td></tr>
<tr class="separator:a0bb1919952d428702d64090f2ea81fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75467ae3bda2dbdcec1e140dada8e41"><td class="memItemLeft" align="right" valign="top"><a id="ad75467ae3bda2dbdcec1e140dada8e41"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad75467ae3bda2dbdcec1e140dada8e41">Lshr</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:ad75467ae3bda2dbdcec1e140dada8e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical right shift with int constant. <br /></td></tr>
<tr class="separator:ad75467ae3bda2dbdcec1e140dada8e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aaed36c9ccdb21be25f46d8350430b"><td class="memItemLeft" align="right" valign="top"><a id="a21aaed36c9ccdb21be25f46d8350430b"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a21aaed36c9ccdb21be25f46d8350430b">operator+</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a21aaed36c9ccdb21be25f46d8350430b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned addition with int constant. <br /></td></tr>
<tr class="separator:a21aaed36c9ccdb21be25f46d8350430b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86888214d74c96271cda87a4f13c9dfc"><td class="memItemLeft" align="right" valign="top"><a id="a86888214d74c96271cda87a4f13c9dfc"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a86888214d74c96271cda87a4f13c9dfc">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a86888214d74c96271cda87a4f13c9dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned subtraction with int constant. <br /></td></tr>
<tr class="separator:a86888214d74c96271cda87a4f13c9dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40770ca14b70a11f277696dc6c6dff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac40770ca14b70a11f277696dc6c6dff2">SetUnsignedComparison</a> (bool sign)</td></tr>
<tr class="separator:ac40770ca14b70a11f277696dc6c6dff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9b38a78f3d3d10857d632479e1a1f6"><td class="memItemLeft" align="right" valign="top"><a id="acb9b38a78f3d3d10857d632479e1a1f6"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acb9b38a78f3d3d10857d632479e1a1f6">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:acb9b38a78f3d3d10857d632479e1a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal. <br /></td></tr>
<tr class="separator:acb9b38a78f3d3d10857d632479e1a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="memItemLeft" align="right" valign="top"><a id="a43c51f6da7b4a7d2e0bb4e5e06300bfb"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a43c51f6da7b4a7d2e0bb4e5e06300bfb">operator!=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal. <br /></td></tr>
<tr class="separator:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297d9e26e0499970d9ec654667861db"><td class="memItemLeft" align="right" valign="top"><a id="af297d9e26e0499970d9ec654667861db"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af297d9e26e0499970d9ec654667861db">operator&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:af297d9e26e0499970d9ec654667861db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than (bit-vectors only). <br /></td></tr>
<tr class="separator:af297d9e26e0499970d9ec654667861db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130a794f0f175d58089d16bcaabb91ae"><td class="memItemLeft" align="right" valign="top"><a id="a130a794f0f175d58089d16bcaabb91ae"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a130a794f0f175d58089d16bcaabb91ae">operator&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a130a794f0f175d58089d16bcaabb91ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:a130a794f0f175d58089d16bcaabb91ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fd64da42d7b62d90e7723fd9b99155"><td class="memItemLeft" align="right" valign="top"><a id="aa6fd64da42d7b62d90e7723fd9b99155"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa6fd64da42d7b62d90e7723fd9b99155">operator&lt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aa6fd64da42d7b62d90e7723fd9b99155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:aa6fd64da42d7b62d90e7723fd9b99155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3c66d75773fcf81726ef3225bf73be"><td class="memItemLeft" align="right" valign="top"><a id="a7a3c66d75773fcf81726ef3225bf73be"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7a3c66d75773fcf81726ef3225bf73be">operator&gt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a7a3c66d75773fcf81726ef3225bf73be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a7a3c66d75773fcf81726ef3225bf73be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d30cc567f56a578def19edd36f92a"><td class="memItemLeft" align="right" valign="top"><a id="a682d30cc567f56a578def19edd36f92a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a682d30cc567f56a578def19edd36f92a">Ult</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a682d30cc567f56a578def19edd36f92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than (bit-vectors only). <br /></td></tr>
<tr class="separator:a682d30cc567f56a578def19edd36f92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="memItemLeft" align="right" valign="top"><a id="ab2853af9ffe113d87fe08efa8e02b7a3"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab2853af9ffe113d87fe08efa8e02b7a3">Ugt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="memItemLeft" align="right" valign="top"><a id="a4f01ce26f38dd0af7c1b90e26d9d42b9"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4f01ce26f38dd0af7c1b90e26d9d42b9">Ule</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35547378b340cdd037b0c3179a4c333b"><td class="memItemLeft" align="right" valign="top"><a id="a35547378b340cdd037b0c3179a4c333b"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a35547378b340cdd037b0c3179a4c333b">Uge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a35547378b340cdd037b0c3179a4c333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a35547378b340cdd037b0c3179a4c333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c20a840cad15d999b2b05bd04de5d5"><td class="memItemLeft" align="right" valign="top"><a id="a80c20a840cad15d999b2b05bd04de5d5"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a80c20a840cad15d999b2b05bd04de5d5">Slt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a80c20a840cad15d999b2b05bd04de5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than (bit-vectors only). <br /></td></tr>
<tr class="separator:a80c20a840cad15d999b2b05bd04de5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a5c8b2290e4a4592c1c7d89ce117d0"><td class="memItemLeft" align="right" valign="top"><a id="aa0a5c8b2290e4a4592c1c7d89ce117d0"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa0a5c8b2290e4a4592c1c7d89ce117d0">Sgt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aa0a5c8b2290e4a4592c1c7d89ce117d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:aa0a5c8b2290e4a4592c1c7d89ce117d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6220de8b3b7523714a03db7b2127152b"><td class="memItemLeft" align="right" valign="top"><a id="a6220de8b3b7523714a03db7b2127152b"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6220de8b3b7523714a03db7b2127152b">Sle</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a6220de8b3b7523714a03db7b2127152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a6220de8b3b7523714a03db7b2127152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd8ac4aa3c6cc7d655fbd34719db722"><td class="memItemLeft" align="right" valign="top"><a id="a8fd8ac4aa3c6cc7d655fbd34719db722"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8fd8ac4aa3c6cc7d655fbd34719db722">Sge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a8fd8ac4aa3c6cc7d655fbd34719db722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a8fd8ac4aa3c6cc7d655fbd34719db722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570a7c815fa28fcaf3cbe903716c124"><td class="memItemLeft" align="right" valign="top"><a id="ac570a7c815fa28fcaf3cbe903716c124"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac570a7c815fa28fcaf3cbe903716c124">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:ac570a7c815fa28fcaf3cbe903716c124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to Boolean constant. <br /></td></tr>
<tr class="separator:ac570a7c815fa28fcaf3cbe903716c124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5988961e07922c24fb867882884968"><td class="memItemLeft" align="right" valign="top"><a id="a0a5988961e07922c24fb867882884968"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0a5988961e07922c24fb867882884968">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a0a5988961e07922c24fb867882884968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to int constant. <br /></td></tr>
<tr class="separator:a0a5988961e07922c24fb867882884968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13309390fcb98b680269a31df32ee983"><td class="memItemLeft" align="right" valign="top"><a id="a13309390fcb98b680269a31df32ee983"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a13309390fcb98b680269a31df32ee983">operator!=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a13309390fcb98b680269a31df32ee983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to int constant. <br /></td></tr>
<tr class="separator:a13309390fcb98b680269a31df32ee983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb89a7f987956d5bd1d9f7233c318d6"><td class="memItemLeft" align="right" valign="top"><a id="accb89a7f987956d5bd1d9f7233c318d6"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#accb89a7f987956d5bd1d9f7233c318d6">operator&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:accb89a7f987956d5bd1d9f7233c318d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:accb89a7f987956d5bd1d9f7233c318d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1048b48f1599debc1925e8d171d6de9"><td class="memItemLeft" align="right" valign="top"><a id="ac1048b48f1599debc1925e8d171d6de9"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac1048b48f1599debc1925e8d171d6de9">operator&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:ac1048b48f1599debc1925e8d171d6de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:ac1048b48f1599debc1925e8d171d6de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa815eeb1ccb2596476fe310a286ed1c"><td class="memItemLeft" align="right" valign="top"><a id="aaa815eeb1ccb2596476fe310a286ed1c"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aaa815eeb1ccb2596476fe310a286ed1c">operator&lt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:aaa815eeb1ccb2596476fe310a286ed1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned less than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:aaa815eeb1ccb2596476fe310a286ed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603ea8347d245f1272a6a81b214d6395"><td class="memItemLeft" align="right" valign="top"><a id="a603ea8347d245f1272a6a81b214d6395"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a603ea8347d245f1272a6a81b214d6395">operator&gt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a603ea8347d245f1272a6a81b214d6395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed/Unsigned greater than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a603ea8347d245f1272a6a81b214d6395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db90d2df4283f54d1cd7d54a45777ea"><td class="memItemLeft" align="right" valign="top"><a id="a1db90d2df4283f54d1cd7d54a45777ea"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1db90d2df4283f54d1cd7d54a45777ea">Ult</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a1db90d2df4283f54d1cd7d54a45777ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a1db90d2df4283f54d1cd7d54a45777ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fdbef3ea0aac6693d4813bee367ad4"><td class="memItemLeft" align="right" valign="top"><a id="a79fdbef3ea0aac6693d4813bee367ad4"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a79fdbef3ea0aac6693d4813bee367ad4">Ugt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a79fdbef3ea0aac6693d4813bee367ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a79fdbef3ea0aac6693d4813bee367ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2bc76f04057367f87de947e733a897"><td class="memItemLeft" align="right" valign="top"><a id="a5e2bc76f04057367f87de947e733a897"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a5e2bc76f04057367f87de947e733a897">Ule</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a5e2bc76f04057367f87de947e733a897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a5e2bc76f04057367f87de947e733a897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2e13c0f75065c992879b4599f0ec5c"><td class="memItemLeft" align="right" valign="top"><a id="abb2e13c0f75065c992879b4599f0ec5c"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abb2e13c0f75065c992879b4599f0ec5c">Uge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:abb2e13c0f75065c992879b4599f0ec5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:abb2e13c0f75065c992879b4599f0ec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f38e9adfcb51fe8d729b24fcfcf78ba"><td class="memItemLeft" align="right" valign="top"><a id="a9f38e9adfcb51fe8d729b24fcfcf78ba"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9f38e9adfcb51fe8d729b24fcfcf78ba">Slt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a9f38e9adfcb51fe8d729b24fcfcf78ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a9f38e9adfcb51fe8d729b24fcfcf78ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ccc2748c1474cd48f65a90b1e18bc7"><td class="memItemLeft" align="right" valign="top"><a id="a06ccc2748c1474cd48f65a90b1e18bc7"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a06ccc2748c1474cd48f65a90b1e18bc7">Sgt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a06ccc2748c1474cd48f65a90b1e18bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a06ccc2748c1474cd48f65a90b1e18bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9989ec0b2fe39a8e776599591b1a563f"><td class="memItemLeft" align="right" valign="top"><a id="a9989ec0b2fe39a8e776599591b1a563f"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9989ec0b2fe39a8e776599591b1a563f">Sle</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a9989ec0b2fe39a8e776599591b1a563f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a9989ec0b2fe39a8e776599591b1a563f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfb823cc06611f9232d6b97c2dbebee"><td class="memItemLeft" align="right" valign="top"><a id="accfb823cc06611f9232d6b97c2dbebee"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#accfb823cc06611f9232d6b97c2dbebee">Sge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:accfb823cc06611f9232d6b97c2dbebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:accfb823cc06611f9232d6b97c2dbebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4006e3000db73b20ee6f06a713d1bd"><td class="memItemLeft" align="right" valign="top"><a id="a1f4006e3000db73b20ee6f06a713d1bd"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1f4006e3000db73b20ee6f06a713d1bd">Load</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;addr)</td></tr>
<tr class="memdesc:a1f4006e3000db73b20ee6f06a713d1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from memory. <br /></td></tr>
<tr class="separator:a1f4006e3000db73b20ee6f06a713d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32b36b718a94a19184be0eaa66e5774"><td class="memItemLeft" align="right" valign="top"><a id="ad32b36b718a94a19184be0eaa66e5774"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad32b36b718a94a19184be0eaa66e5774">Store</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;addr, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;data)</td></tr>
<tr class="memdesc:ad32b36b718a94a19184be0eaa66e5774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store to memory. <br /></td></tr>
<tr class="separator:ad32b36b718a94a19184be0eaa66e5774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa9ea7950a14ee2aeee819185b552b5"><td class="memItemLeft" align="right" valign="top"><a id="a3aa9ea7950a14ee2aeee819185b552b5"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a3aa9ea7950a14ee2aeee819185b552b5">Load</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const int &amp;addr)</td></tr>
<tr class="memdesc:a3aa9ea7950a14ee2aeee819185b552b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from memory with constant address. <br /></td></tr>
<tr class="separator:a3aa9ea7950a14ee2aeee819185b552b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9db91d7f135f2abb8b3aee379850c01"><td class="memItemLeft" align="right" valign="top"><a id="ab9db91d7f135f2abb8b3aee379850c01"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab9db91d7f135f2abb8b3aee379850c01">Store</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const int &amp;addr, const int &amp;data)</td></tr>
<tr class="memdesc:ab9db91d7f135f2abb8b3aee379850c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store to memory at constant address and data. <br /></td></tr>
<tr class="separator:ab9db91d7f135f2abb8b3aee379850c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b423140c9b8a60e1bac56e90ba175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa74b423140c9b8a60e1bac56e90ba175">Concat</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;msbv, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;lsbv)</td></tr>
<tr class="memdesc:aa74b423140c9b8a60e1bac56e90ba175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two bit-vectors.  <a href="#aa74b423140c9b8a60e1bac56e90ba175">More...</a><br /></td></tr>
<tr class="separator:aa74b423140c9b8a60e1bac56e90ba175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73a95aa5988d50567c5ff6fe53de913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab73a95aa5988d50567c5ff6fe53de913">Extract</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;hi, const int &amp;lo)</td></tr>
<tr class="memdesc:ab73a95aa5988d50567c5ff6fe53de913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract bit-field in the bit-vector.  <a href="#ab73a95aa5988d50567c5ff6fe53de913">More...</a><br /></td></tr>
<tr class="separator:ab73a95aa5988d50567c5ff6fe53de913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a28a510ed3c6bbe8cb314bdfb8d664283">SelectBit</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;idx)</td></tr>
<tr class="memdesc:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract single bit in the bit-vector.  <a href="#a28a510ed3c6bbe8cb314bdfb8d664283">More...</a><br /></td></tr>
<tr class="separator:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad992886a38803601f88f987b174f4c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad992886a38803601f88f987b174f4c34">ZExt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;length)</td></tr>
<tr class="memdesc:ad992886a38803601f88f987b174f4c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extend the bit-vector to the specified length.  <a href="#ad992886a38803601f88f987b174f4c34">More...</a><br /></td></tr>
<tr class="separator:ad992886a38803601f88f987b174f4c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a2da11f53d77bc38c204c87f6eecda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae0a2da11f53d77bc38c204c87f6eecda">SExt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;length)</td></tr>
<tr class="memdesc:ae0a2da11f53d77bc38c204c87f6eecda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the bit-vector to the specified length.  <a href="#ae0a2da11f53d77bc38c204c87f6eecda">More...</a><br /></td></tr>
<tr class="separator:ae0a2da11f53d77bc38c204c87f6eecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717385221eb8322e7b19096ba48d2516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a717385221eb8322e7b19096ba48d2516">Imply</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;ante, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;cons)</td></tr>
<tr class="memdesc:a717385221eb8322e7b19096ba48d2516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical imply for Booleans.  <a href="#a717385221eb8322e7b19096ba48d2516">More...</a><br /></td></tr>
<tr class="separator:a717385221eb8322e7b19096ba48d2516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63ed74adc72075df524ec933146f0f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab63ed74adc72075df524ec933146f0f3">Ite</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;cond, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;t, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;f)</td></tr>
<tr class="memdesc:ab63ed74adc72075df524ec933146f0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If-then-else on the Boolean condition.  <a href="#ab63ed74adc72075df524ec933146f0f3">More...</a><br /></td></tr>
<tr class="separator:ab63ed74adc72075df524ec933146f0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a41b370cb62e6bb2a4abba9b9f482ff6f">BoolConst</a> (bool bool_val)</td></tr>
<tr class="memdesc:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Boolean constant.  <a href="#a41b370cb62e6bb2a4abba9b9f482ff6f">More...</a><br /></td></tr>
<tr class="separator:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c81eb12aece5b37849917b2dee95695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2c81eb12aece5b37849917b2dee95695">BvConst</a> (const int &amp;bv_val, const int &amp;bit_width)</td></tr>
<tr class="memdesc:a2c81eb12aece5b37849917b2dee95695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bit-vector constant.  <a href="#a2c81eb12aece5b37849917b2dee95695">More...</a><br /></td></tr>
<tr class="separator:a2c81eb12aece5b37849917b2dee95695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aabcae2083096742642384a583eb06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4aabcae2083096742642384a583eb06f">MemConst</a> (const int &amp;def_val, const std::map&lt; int, int &gt; &amp;vals, const int &amp;addr_width, const int &amp;data_width)</td></tr>
<tr class="memdesc:a4aabcae2083096742642384a583eb06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a memory constant.  <a href="#a4aabcae2083096742642384a583eb06f">More...</a><br /></td></tr>
<tr class="separator:a4aabcae2083096742642384a583eb06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc42fabe7c53eadf8db66da979cd156"><td class="memItemLeft" align="right" valign="top"><a id="aafc42fabe7c53eadf8db66da979cd156"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aafc42fabe7c53eadf8db66da979cd156">TopEqual</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aafc42fabe7c53eadf8db66da979cd156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically equivalent. <br /></td></tr>
<tr class="separator:aafc42fabe7c53eadf8db66da979cd156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="memItemLeft" align="right" valign="top"><a id="ab9bcc3ec35bb95561155203ab61e2e0d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab9bcc3ec35bb95561155203ab61e2e0d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;expr)</td></tr>
<tr class="memdesc:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the <a class="el" href="classilang_1_1_expr_ref.html" title="The wrapper of Expr (e.g. state var, var relation, constant, etc). ">ExprRef</a>. <br /></td></tr>
<tr class="separator:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7e5decaea56c186a7576ddf30379b"><td class="memItemLeft" align="right" valign="top"><a id="a36a7e5decaea56c186a7576ddf30379b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a36a7e5decaea56c186a7576ddf30379b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_instr_ref.html">InstrRef</a> &amp;instr)</td></tr>
<tr class="memdesc:a36a7e5decaea56c186a7576ddf30379b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the Instruction. <br /></td></tr>
<tr class="separator:a36a7e5decaea56c186a7576ddf30379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="memItemLeft" align="right" valign="top"><a id="a6a1bf9ab1a26dcdd7ac71b99181c96ac"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6a1bf9ab1a26dcdd7ac71b99181c96ac">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;ila)</td></tr>
<tr class="memdesc:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the ILA. <br /></td></tr>
<tr class="separator:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181bcd7690eed0466a301469995543a4"><td class="memItemLeft" align="right" valign="top"><a id="a181bcd7690eed0466a301469995543a4"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a181bcd7690eed0466a301469995543a4">Z3And</a> (const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a181bcd7690eed0466a301469995543a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is just a shortcut to be used for generated axiom. <br /></td></tr>
<tr class="separator:a181bcd7690eed0466a301469995543a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f0ebb2ec25f3584a4e5618e3878fe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a18f0ebb2ec25f3584a4e5618e3878fe4">ExportPortableToFile</a> (const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;ila, const std::string &amp;file)</td></tr>
<tr class="memdesc:a18f0ebb2ec25f3584a4e5618e3878fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the ILA portable to a file.  <a href="#a18f0ebb2ec25f3584a4e5618e3878fe4">More...</a><br /></td></tr>
<tr class="separator:a18f0ebb2ec25f3584a4e5618e3878fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84abd51cf83ad7f00802caae2853e628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a84abd51cf83ad7f00802caae2853e628">ImportPortableFromFile</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a84abd51cf83ad7f00802caae2853e628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import the ILA model from the file.  <a href="#a84abd51cf83ad7f00802caae2853e628">More...</a><br /></td></tr>
<tr class="separator:a84abd51cf83ad7f00802caae2853e628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6810cc71b8a884538774f9f0cae4a48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad6810cc71b8a884538774f9f0cae4a48">ImportSynthAbsFromFile</a> (const std::string &amp;file_name, const std::string &amp;ila_name=&quot;&quot;)</td></tr>
<tr class="memdesc:ad6810cc71b8a884538774f9f0cae4a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from file the abstraction from the synthesis engine and convert it into an ILA model.  <a href="#ad6810cc71b8a884538774f9f0cae4a48">More...</a><br /></td></tr>
<tr class="separator:ad6810cc71b8a884538774f9f0cae4a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1380087070c036209a6000d2034586b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa1380087070c036209a6000d2034586b">ImportSynthAbsFromFileHier</a> (const std::string &amp;file_name, const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> parent, const std::string &amp;ila_name=&quot;&quot;)</td></tr>
<tr class="memdesc:aa1380087070c036209a6000d2034586b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from file the abstraction from the synthesis engine and convert it into a child-ILA of the specified parent ILA.  <a href="#aa1380087070c036209a6000d2034586b">More...</a><br /></td></tr>
<tr class="separator:aa1380087070c036209a6000d2034586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca5c66b61666678437e9145181ec121"><td class="memItemLeft" align="right" valign="top"><a id="aeca5c66b61666678437e9145181ec121"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeca5c66b61666678437e9145181ec121">os_portable_mkdir</a> (const std::string &amp;dir)</td></tr>
<tr class="memdesc:aeca5c66b61666678437e9145181ec121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dir, true -&gt; suceeded , ow false. <br /></td></tr>
<tr class="separator:aeca5c66b61666678437e9145181ec121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd59e78d3468c65ac2ca90374046fbd"><td class="memItemLeft" align="right" valign="top"><a id="aefd59e78d3468c65ac2ca90374046fbd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aefd59e78d3468c65ac2ca90374046fbd">os_portable_copy_dir</a> (const std::string &amp;src, const std::string &amp;dst)</td></tr>
<tr class="memdesc:aefd59e78d3468c65ac2ca90374046fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all file from a source dir to the destination dir. <br /></td></tr>
<tr class="separator:aefd59e78d3468c65ac2ca90374046fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9d76f39d3c86e48d40510503f8fa7b"><td class="memItemLeft" align="right" valign="top"><a id="a1e9d76f39d3c86e48d40510503f8fa7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1e9d76f39d3c86e48d40510503f8fa7b">os_portable_copy_file_to_dir</a> (const std::string &amp;src, const std::string &amp;dst)</td></tr>
<tr class="memdesc:a1e9d76f39d3c86e48d40510503f8fa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one file to the destination dir. <br /></td></tr>
<tr class="separator:a1e9d76f39d3c86e48d40510503f8fa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1adaa03ee7643f536c411bbd19dcbe"><td class="memItemLeft" align="right" valign="top"><a id="aed1adaa03ee7643f536c411bbd19dcbe"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aed1adaa03ee7643f536c411bbd19dcbe">os_portable_append_dir</a> (const std::string &amp;dir1, const std::string &amp;dir2)</td></tr>
<tr class="memdesc:aed1adaa03ee7643f536c411bbd19dcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append two path (you have to decide whether it is / or ) <br /></td></tr>
<tr class="separator:aed1adaa03ee7643f536c411bbd19dcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f4521ec82c6af4695e31e917082828"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a79f4521ec82c6af4695e31e917082828">os_portable_file_name_from_path</a> (const std::string &amp;path)</td></tr>
<tr class="separator:a79f4521ec82c6af4695e31e917082828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5002dc8078f121ff03b282d1637b4c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad5002dc8078f121ff03b282d1637b4c0">SetLogLevel</a> (const int &amp;lvl)</td></tr>
<tr class="memdesc:ad5002dc8078f121ff03b282d1637b4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimun log level. Log messages at or above this level will be logged. (Default: 0)  <a href="#ad5002dc8078f121ff03b282d1637b4c0">More...</a><br /></td></tr>
<tr class="separator:ad5002dc8078f121ff03b282d1637b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad694e631ce9de3140f3d3991f87728"><td class="memItemLeft" align="right" valign="top"><a id="a4ad694e631ce9de3140f3d3991f87728"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4ad694e631ce9de3140f3d3991f87728">SetLogPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a4ad694e631ce9de3140f3d3991f87728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path for log file. If specified, logfiles are written into this directory instead of the default logging directory (/tmp). <br /></td></tr>
<tr class="separator:a4ad694e631ce9de3140f3d3991f87728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297a8bf42d97a385aa18916321c6bce6"><td class="memItemLeft" align="right" valign="top"><a id="a297a8bf42d97a385aa18916321c6bce6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a297a8bf42d97a385aa18916321c6bce6">SetToStdErr</a> (const int &amp;to_err)</td></tr>
<tr class="memdesc:a297a8bf42d97a385aa18916321c6bce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe log to stderr. Log messages to stderr instead of logfiles, if set to 1. <br /></td></tr>
<tr class="separator:a297a8bf42d97a385aa18916321c6bce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0991fc567e0acf208e32077bfa58c0e8"><td class="memItemLeft" align="right" valign="top"><a id="a0991fc567e0acf208e32077bfa58c0e8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0991fc567e0acf208e32077bfa58c0e8">StrToUpper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a0991fc567e0acf208e32077bfa58c0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basic string to upper case. <br /></td></tr>
<tr class="separator:a0991fc567e0acf208e32077bfa58c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cdb1960acea845bdad15ad077fb1e7"><td class="memItemLeft" align="right" valign="top"><a id="a44cdb1960acea845bdad15ad077fb1e7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a44cdb1960acea845bdad15ad077fb1e7">StrToLower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a44cdb1960acea845bdad15ad077fb1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basic string to lower case. <br /></td></tr>
<tr class="separator:a44cdb1960acea845bdad15ad077fb1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf3586b9c4507e7a8ba88bb181b158"><td class="memItemLeft" align="right" valign="top"><a id="a10cf3586b9c4507e7a8ba88bb181b158"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a10cf3586b9c4507e7a8ba88bb181b158">StrToBool</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a10cf3586b9c4507e7a8ba88bb181b158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string is "true" or "True". <br /></td></tr>
<tr class="separator:a10cf3586b9c4507e7a8ba88bb181b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc40506a335870a67d4ff33bbf9f778"><td class="memItemLeft" align="right" valign="top"><a id="a1dc40506a335870a67d4ff33bbf9f778"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1dc40506a335870a67d4ff33bbf9f778">StrToInt</a> (const std::string &amp;str, int base=10)</td></tr>
<tr class="memdesc:a1dc40506a335870a67d4ff33bbf9f778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value represented in the string, e.g. "10". <br /></td></tr>
<tr class="separator:a1dc40506a335870a67d4ff33bbf9f778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0044ba6e7d230be9715ebee1ec77dcae"><td class="memItemLeft" align="right" valign="top"><a id="a0044ba6e7d230be9715ebee1ec77dcae"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0044ba6e7d230be9715ebee1ec77dcae">Split</a> (const std::string &amp;str, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a0044ba6e7d230be9715ebee1ec77dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-style split , return a vector of splitted strings. <br /></td></tr>
<tr class="separator:a0044ba6e7d230be9715ebee1ec77dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c4d3feea37017130bce31eb66db90"><td class="memItemLeft" align="right" valign="top"><a id="a668c4d3feea37017130bce31eb66db90"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a668c4d3feea37017130bce31eb66db90">SplitSpaceTabEnter</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a668c4d3feea37017130bce31eb66db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-style split behavior, delim: space tab enter and their combiniations. <br /></td></tr>
<tr class="separator:a668c4d3feea37017130bce31eb66db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7f41f64940afe64a721f33752b619c"><td class="memItemLeft" align="right" valign="top"><a id="aeb7f41f64940afe64a721f33752b619c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeb7f41f64940afe64a721f33752b619c">Join</a> (const std::vector&lt; std::string &gt; &amp;in, const std::string &amp;delim)</td></tr>
<tr class="memdesc:aeb7f41f64940afe64a721f33752b619c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-style join, return a string that joins the list by the delim. <br /></td></tr>
<tr class="separator:aeb7f41f64940afe64a721f33752b619c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edef00da62caf959c84b6cff88b035d"><td class="memItemLeft" align="right" valign="top"><a id="a7edef00da62caf959c84b6cff88b035d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7edef00da62caf959c84b6cff88b035d">ReplaceAll</a> (const std::string &amp;str, const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a7edef00da62caf959c84b6cff88b035d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrance of substring a by substring b. <br /></td></tr>
<tr class="separator:a7edef00da62caf959c84b6cff88b035d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1f77ed0ab47a14e63fde64bbdad506"><td class="memItemLeft" align="right" valign="top"><a id="a8d1f77ed0ab47a14e63fde64bbdad506"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8d1f77ed0ab47a14e63fde64bbdad506">ReFindList</a> (const std::string &amp;s, const std::string &amp;re)</td></tr>
<tr class="memdesc:a8d1f77ed0ab47a14e63fde64bbdad506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out a list of substring by the regular expression. <br /></td></tr>
<tr class="separator:a8d1f77ed0ab47a14e63fde64bbdad506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f5d61665a892dad75f4db1fbcc5ef0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a53f5d61665a892dad75f4db1fbcc5ef0">ReFindAndDo</a> (const std::string &amp;s, const std::string &amp;re, std::function&lt; std::string(std::string)&gt; f)</td></tr>
<tr class="separator:a53f5d61665a892dad75f4db1fbcc5ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc31e7540cbe817478e2833f4766d07"><td class="memItemLeft" align="right" valign="top"><a id="aefc31e7540cbe817478e2833f4766d07"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRExprUsable</b> ()</td></tr>
<tr class="separator:aefc31e7540cbe817478e2833f4766d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebfc3854c74ab3f2d1bd4e44305692f"><td class="memItemLeft" align="right" valign="top"><a id="adebfc3854c74ab3f2d1bd4e44305692f"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adebfc3854c74ab3f2d1bd4e44305692f">Z3Implies</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:adebfc3854c74ab3f2d1bd4e44305692f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 implies ast node construction. <br /></td></tr>
<tr class="separator:adebfc3854c74ab3f2d1bd4e44305692f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c925e40db7a9745e41f1bbceabc9fd"><td class="memItemLeft" align="right" valign="top"><a id="a27c925e40db7a9745e41f1bbceabc9fd"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a27c925e40db7a9745e41f1bbceabc9fd">Z3Shl</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a27c925e40db7a9745e41f1bbceabc9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 shl ast node construction. <br /></td></tr>
<tr class="separator:a27c925e40db7a9745e41f1bbceabc9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfa4e4993b16400643d2d217342116a"><td class="memItemLeft" align="right" valign="top"><a id="aebfa4e4993b16400643d2d217342116a"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aebfa4e4993b16400643d2d217342116a">Z3Ashr</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:aebfa4e4993b16400643d2d217342116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 ashr ast node construction. <br /></td></tr>
<tr class="separator:aebfa4e4993b16400643d2d217342116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3aaf13ea691b9badc083bc800d8786"><td class="memItemLeft" align="right" valign="top"><a id="a7d3aaf13ea691b9badc083bc800d8786"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7d3aaf13ea691b9badc083bc800d8786">Z3Lshr</a> (z3::context &amp;ctx, const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a7d3aaf13ea691b9badc083bc800d8786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 lshr ast node construction. <br /></td></tr>
<tr class="separator:a7d3aaf13ea691b9badc083bc800d8786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd62d7446c3eacdba8fb30edbc0e7fae"><td class="memItemLeft" align="right" valign="top"><a id="abd62d7446c3eacdba8fb30edbc0e7fae"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abd62d7446c3eacdba8fb30edbc0e7fae">Z3ZExt</a> (z3::context &amp;ctx, const z3::expr &amp;e, const unsigned &amp;w)</td></tr>
<tr class="memdesc:abd62d7446c3eacdba8fb30edbc0e7fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 zext ast node construction. <br /></td></tr>
<tr class="separator:abd62d7446c3eacdba8fb30edbc0e7fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e7a7410240e86668b47d5201edc102"><td class="memItemLeft" align="right" valign="top"><a id="a57e7a7410240e86668b47d5201edc102"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a57e7a7410240e86668b47d5201edc102">Z3SExt</a> (z3::context &amp;ctx, const z3::expr &amp;e, const unsigned &amp;w)</td></tr>
<tr class="memdesc:a57e7a7410240e86668b47d5201edc102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface z3 sext ast node construction. <br /></td></tr>
<tr class="separator:a57e7a7410240e86668b47d5201edc102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ebb4cd13cdea9917d3e2b7cc3bfbbb"><td class="memItemLeft" align="right" valign="top"><a id="a78ebb4cd13cdea9917d3e2b7cc3bfbbb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a78ebb4cd13cdea9917d3e2b7cc3bfbbb">Z3Expr2String</a> (z3::context &amp;ctx, const z3::expr &amp;e)</td></tr>
<tr class="memdesc:a78ebb4cd13cdea9917d3e2b7cc3bfbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the output string of the given z3::expr. <br /></td></tr>
<tr class="separator:a78ebb4cd13cdea9917d3e2b7cc3bfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e964690ec5bb80e51e35cb3b73c024"><td class="memItemLeft" align="right" valign="top"><a id="ad4e964690ec5bb80e51e35cb3b73c024"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad4e964690ec5bb80e51e35cb3b73c024">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classilang_1_1_verilog_analyzer_base.html#a218c0476db4d9516652f3cfa104a9d34">VerilogAnalyzerBase::vlg_loc_t</a> &amp;obj)</td></tr>
<tr class="memdesc:ad4e964690ec5bb80e51e35cb3b73c024"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload the operator &lt;&lt; for printing location <br /></td></tr>
<tr class="separator:ad4e964690ec5bb80e51e35cb3b73c024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f8e2034f6578c089d6ceb5600cab7d"><td class="memItemLeft" align="right" valign="top"><a id="a01f8e2034f6578c089d6ceb5600cab7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TestParseVerilog</b> ()</td></tr>
<tr class="separator:a01f8e2034f6578c089d6ceb5600cab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bc7ea62eac3a9dd0dfcc0337abe99d"><td class="memItemLeft" align="right" valign="top"><a id="a80bc7ea62eac3a9dd0dfcc0337abe99d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TestParseVerilogFrom</b> (std::FILE *fp)</td></tr>
<tr class="separator:a80bc7ea62eac3a9dd0dfcc0337abe99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the core data structure and APIs for constructing and storing ILA. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a41b370cb62e6bb2a4abba9b9f482ff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b370cb62e6bb2a4abba9b9f482ff6f">&#9670;&nbsp;</a></span>BoolConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::BoolConst </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bool_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Boolean constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bool_val</td><td>value of the Boolean constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c81eb12aece5b37849917b2dee95695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c81eb12aece5b37849917b2dee95695">&#9670;&nbsp;</a></span>BvConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::BvConst </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>bv_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>bit_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a bit-vector constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv_val</td><td>value of the bit-vector constant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>data bit-width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa74b423140c9b8a60e1bac56e90ba175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b423140c9b8a60e1bac56e90ba175">&#9670;&nbsp;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>msbv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>lsbv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two bit-vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msbv</td><td>bit-vector on the more-significant side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsbv</td><td>bit-vector on the less-significant side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f0ebb2ec25f3584a4e5618e3878fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f0ebb2ec25f3584a4e5618e3878fe4">&#9670;&nbsp;</a></span>ExportPortableToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ilang::ExportPortableToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ila</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the ILA portable to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ila</td><td>pointer to the ila model to be exported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>output file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>export status. </dd></dl>

</div>
</div>
<a id="ab73a95aa5988d50567c5ff6fe53de913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73a95aa5988d50567c5ff6fe53de913">&#9670;&nbsp;</a></span>Extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract bit-field in the bit-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>the index of the most-significant bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lo</td><td>the index of the least-significant bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717385221eb8322e7b19096ba48d2516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717385221eb8322e7b19096ba48d2516">&#9670;&nbsp;</a></span>Imply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Imply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>ante</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical imply for Booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ante</td><td>antecedent for the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cons</td><td>consequent for the operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84abd51cf83ad7f00802caae2853e628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84abd51cf83ad7f00802caae2853e628">&#9670;&nbsp;</a></span>ImportPortableFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> ilang::ImportPortableFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import the ILA model from the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>input file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generated ILA model. </dd></dl>

</div>
</div>
<a id="ad6810cc71b8a884538774f9f0cae4a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6810cc71b8a884538774f9f0cae4a48">&#9670;&nbsp;</a></span>ImportSynthAbsFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> ilang::ImportSynthAbsFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ila_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from file the abstraction from the synthesis engine and convert it into an ILA model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>file name of the abstraction from the synthesis engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ila_name</td><td>name of the created ILA model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generated ILA model. </dd></dl>

</div>
</div>
<a id="aa1380087070c036209a6000d2034586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1380087070c036209a6000d2034586b">&#9670;&nbsp;</a></span>ImportSynthAbsFromFileHier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> ilang::ImportSynthAbsFromFileHier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ila_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from file the abstraction from the synthesis engine and convert it into a child-ILA of the specified parent ILA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>file name of the abstraction from the synthesis engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>pointer to the parent ILA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ila_name</td><td>name of the created ILA model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generated ILA model. </dd></dl>

</div>
</div>
<a id="ab63ed74adc72075df524ec933146f0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63ed74adc72075df524ec933146f0f3">&#9670;&nbsp;</a></span>Ite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Ite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If-then-else on the Boolean condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>Boolean type condition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Expression to take when the condition is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Expression to take when the condition is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38808a9aed62a8c4a6917621c9318d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38808a9aed62a8c4a6917621c9318d6e">&#9670;&nbsp;</a></span>LogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::LogLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimun log level. Log messages at or above this level will be logged. (Default: 0) </p>
<ul>
<li>INFO: level 0</li>
<li>WARNING: level 1</li>
<li>ERROR: level 2</li>
<li>FATAL: level 3 </li>
</ul>

</div>
</div>
<a id="a4aabcae2083096742642384a583eb06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aabcae2083096742642384a583eb06f">&#9670;&nbsp;</a></span>MemConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::MemConst </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>def_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>addr_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>data_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a memory constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">def_val</td><td>default value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>non-default address-data mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_width</td><td>address bit-width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_width</td><td>data bit-width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79f4521ec82c6af4695e31e917082828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f4521ec82c6af4695e31e917082828">&#9670;&nbsp;</a></span>os_portable_file_name_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ilang::os_portable_file_name_from_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract filename from path C:<em></em> <b></b> <code></code>.txt -&gt; c.txt d/e/ghi -&gt; ghi </p>

</div>
</div>
<a id="a53f5d61665a892dad75f4db1fbcc5ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f5d61665a892dad75f4db1fbcc5ef0">&#9670;&nbsp;</a></span>ReFindAndDo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; ilang::ReFindAndDo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::string(std::string)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filter out a list of substring by the regular expression, call f each time and use its return value in the list, f can also do something else in itself </p>

</div>
</div>
<a id="a28a510ed3c6bbe8cb314bdfb8d664283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a510ed3c6bbe8cb314bdfb8d664283">&#9670;&nbsp;</a></span>SelectBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::SelectBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract single bit in the bit-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>the index of the selected bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5002dc8078f121ff03b282d1637b4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5002dc8078f121ff03b282d1637b4c0">&#9670;&nbsp;</a></span>SetLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::SetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimun log level. Log messages at or above this level will be logged. (Default: 0) </p>
<ul>
<li>INFO: level 0</li>
<li>WARNING: level 1</li>
<li>ERROR: level 2</li>
<li>FATAL: level 3 </li>
</ul>

</div>
</div>
<a id="ac40770ca14b70a11f277696dc6c6dff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40770ca14b70a11f277696dc6c6dff2">&#9670;&nbsp;</a></span>SetUnsignedComparison()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::SetUnsignedComparison </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the default behavior of operator &lt;, &lt;=, &gt; and &gt;=, by default, signed compare </p>

</div>
</div>
<a id="ae0a2da11f53d77bc38c204c87f6eecda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a2da11f53d77bc38c204c87f6eecda">&#9670;&nbsp;</a></span>SExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::SExt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign-extend the bit-vector to the specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>bit-width of the extended (result) bit-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad992886a38803601f88f987b174f4c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad992886a38803601f88f987b174f4c34">&#9670;&nbsp;</a></span>ZExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::ZExt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero-extend the bit-vector to the specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>bit-width of the extended (result) bit-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
